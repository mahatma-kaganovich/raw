This is basic working patch for both 4.14 & 4.15-next for Wacom 5020.
Some reordered to patch compatibility.
2do: figure out only required, remove I2C_HID_READ_PENDING (?), etc.

--- a/drivers/hid/i2c-hid/i2c-hid.c	2017-12-08 04:27:18.601698533 +0300
+++ a/drivers/hid/i2c-hid/i2c-hid.c	2017-12-08 04:40:47.878556307 +0300
@@ -45,6 +45,7 @@
 #include "../hid-ids.h"
 
 /* quirks to control the device */
+#define I2C_HID_QUIRK_NO_CONTROL		BIT(2)
 #define I2C_HID_QUIRK_SET_PWR_WAKEUP_DEV	BIT(0)
 #define I2C_HID_QUIRK_NO_IRQ_AFTER_RESET	BIT(1)
 
@@ -165,6 +166,8 @@ static const struct i2c_hid_quirks {
 	__u16 idProduct;
 	__u32 quirks;
 } i2c_hid_quirks[] = {
+	{ USB_VENDOR_ID_WACOM, 0x5020,
+		I2C_HID_QUIRK_NO_CONTROL|I2C_HID_QUIRK_SET_PWR_WAKEUP_DEV},
 	{ USB_VENDOR_ID_WEIDA, USB_DEVICE_ID_WEIDA_8752,
 		I2C_HID_QUIRK_SET_PWR_WAKEUP_DEV },
 	{ USB_VENDOR_ID_WEIDA, USB_DEVICE_ID_WEIDA_8755,
@@ -330,6 +336,9 @@ static int i2c_hid_set_or_send_report(st
 	int args_len;
 	int index = 0;
 
+	if (ihid->quirks & I2C_HID_QUIRK_NO_CONTROL)
+		return 0;
+
 	i2c_hid_dbg(ihid, "%s\n", __func__);
 
 	if (data_len > ihid->bufsize)
@@ -418,6 +430,9 @@ static int i2c_hid_hwreset(struct i2c_cl
 	struct i2c_hid *ihid = i2c_get_clientdata(client);
 	int ret;
 
+	if (ihid->quirks & I2C_HID_QUIRK_NO_CONTROL)
+		return 0;
+
 	i2c_hid_dbg(ihid, "%s\n", __func__);
 
 	/*
@@ -499,10 +514,12 @@ static irqreturn_t i2c_hid_irq(int irq,
 {
 	struct i2c_hid *ihid = dev_id;
 
+	mutex_lock(&ihid->reset_lock);
 	if (test_bit(I2C_HID_READ_PENDING, &ihid->flags))
 		return IRQ_HANDLED;
 
 	i2c_hid_get_input(ihid);
+	mutex_unlock(&ihid->reset_lock);
 
 	return IRQ_HANDLED;
 }
@@ -808,6 +825,7 @@ static int i2c_hid_init_irq(struct i2c_c
 
 	if (!irq_get_trigger_type(client->irq))
 		irqflags = IRQF_TRIGGER_LOW;
+	irqflags|=IRQF_IRQPOLL;
 
 	ret = request_threaded_irq(client->irq, NULL, i2c_hid_irq,
 				   irqflags | IRQF_ONESHOT, client->name, ihid);
