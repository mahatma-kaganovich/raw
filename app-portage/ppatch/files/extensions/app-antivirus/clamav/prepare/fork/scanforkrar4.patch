Fork [at least] libclamunrar to avoid kill whole clamd
by library exception and exploit.

Signed-off-by: Dzianis Kahanovich <mahatma@eu.by>

--- a/libclamav/scanners.c1	2023-02-26 15:19:35.752642573 +0300
+++ b/libclamav/scanners.c	2023-02-27 19:11:05.896512052 +0300
@@ -187,6 +187,22 @@ done:
     return status;
 }
 
+#if 1
+#define SCANFORK(ret, cli) { \
+    static pid_t mainpid = 0; \
+    pid_t pid; \
+    int pid_stat; \
+    pid = getpid(); \
+    if (!mainpid) mainpid = pid; \
+    if (mainpid != pid) ret = (cli); \
+    else if (!(pid = fork())) exit((cli)); \
+    /* fatal error -> exploit -> CL_VIRUS */ \
+    else ret = (pid == -1) ? CL_EUNPACK : (waitpid(pid,&pid_stat,0) > 0 && WIFEXITED(pid_stat)) ? WEXITSTATUS(pid_stat): CL_VIRUS; \
+ }
+#else
+#define SCANFORK(ret, cli) ret = (cli)
+#endif
+
 /**
  * @brief  Scan the metadata using cli_matchmeta()
  *
@@ -3540,7 +3556,7 @@ static cl_error_t scanraw(cli_ctx *ctx,
                                     break;
                                 }
 
-                                nret = cli_scanrar(ctx);
+                                SCANFORK(nret,cli_scanrar(ctx));
 
                                 (void)cli_recursion_stack_pop(ctx);
                             }
@@ -4540,7 +4556,7 @@ cl_error_t cli_magic_scan(cli_ctx *ctx,
 
         case CL_TYPE_RAR:
             if (have_rar && SCAN_PARSE_ARCHIVE && (DCONF_ARCH & ARCH_CONF_RAR))
-                ret = cli_scanrar(ctx);
+                SCANFORK(ret,cli_scanrar(ctx));
             break;
 
         case CL_TYPE_EGG:
