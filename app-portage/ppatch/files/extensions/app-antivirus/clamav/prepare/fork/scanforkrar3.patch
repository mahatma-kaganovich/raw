Fork [at least] libclamunrar to avoid kill whole clamd
by library exception and exploit.

Signed-off-by: Dzianis Kahanovich <mahatma@eu.by>

--- a/libclamav/scanners.c	2023-02-26 15:19:35.752642573 +0300
+++ b/libclamav/scanners.c	2023-02-27 05:40:07.050857840 +0300
@@ -187,6 +187,23 @@ done:
     return status;
 }
 
+#if 1
+int scanfork_disable = false;
+#define SCANFORK(ret, cli) { \
+ if (scanfork_disable) ret = (cli); \
+ else { \
+    scanfork_disable = true; \
+    pid_t pid = fork(); \
+    int pid_stat; \
+    if (pid == 0) exit((cli)); \
+    /* fatal error -> exploit -> CL_VIRUS */ \
+    else ret = (pid == -1) ? CL_EUNPACK : (waitpid(pid,&pid_stat,0) > 0 && WIFEXITED(pid_stat)) ? WEXITSTATUS(pid_stat): CL_VIRUS; \
+    scanfork_disable = false; \
+  }}
+#else
+#define SCANFORK(ret, cli) ret = (cli)
+#endif
+
 /**
  * @brief  Scan the metadata using cli_matchmeta()
  *
@@ -3540,7 +3557,7 @@ static cl_error_t scanraw(cli_ctx *ctx,
                                     break;
                                 }
 
-                                nret = cli_scanrar(ctx);
+                                SCANFORK(nret,cli_scanrar(ctx));
 
                                 (void)cli_recursion_stack_pop(ctx);
                             }
@@ -4540,7 +4557,7 @@ cl_error_t cli_magic_scan(cli_ctx *ctx,
 
         case CL_TYPE_RAR:
             if (have_rar && SCAN_PARSE_ARCHIVE && (DCONF_ARCH & ARCH_CONF_RAR))
-                ret = cli_scanrar(ctx);
+                SCANFORK(ret,cli_scanrar(ctx));
             break;
 
         case CL_TYPE_EGG:
