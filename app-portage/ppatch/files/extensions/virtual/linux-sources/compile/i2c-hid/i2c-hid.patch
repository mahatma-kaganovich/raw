Similar patch I send to vger, but there added serialization of
regulator_enable() too. Personally I have no ("dummy") regulator and think
about it later, but as soon main (i2c) part will be included (or rejected)
in kernel - I will think more.

--- a/drivers/hid/i2c-hid/i2c-hid.c	2017-12-17 15:13:10.089624753 +0300
+++ b/drivers/hid/i2c-hid/i2c-hid.c	2017-12-18 02:39:50.677588022 +0300
@@ -60,6 +60,12 @@ static bool debug;
 module_param(debug, bool, 0444);
 MODULE_PARM_DESC(debug, "print a lot of debug information");
 
+/* default post power on delay */
+/* for some of strange devices or i2c like WCOM5020 even 1000 is enough */
+static int post_power_delay_ms_default;
+module_param(post_power_delay_ms_default, int, 0444);
+MODULE_PARM_DESC(post_power_delay_ms_default, "default post power-on delay, ms");
+
 #define i2c_hid_dbg(ihid, fmt, arg...)					  \
 do {									  \
 	if (debug)							  \
@@ -378,7 +384,24 @@ static int i2c_hid_set_or_send_report(st
 	return data_len;
 }
 
-static int i2c_hid_set_power(struct i2c_client *client, int power_state)
+/* Agnostic calling twice: after regulator "power on" & hid cmd "power on" */
+static inline void i2c_hid_power_delay(struct i2c_hid *ihid)
+{
+	/*
+	 * The HID over I2C specification states that if a DEVICE needs time
+	 * after the PWR_ON request, it should utilise CLOCK stretching.
+	 * However, it has been observered that the Windows driver provides a
+	 * 1ms sleep between the PWR_ON and RESET requests and that some devices
+	 * rely on this.
+	 */
+	if (ihid->pdata.post_power_delay_ms)
+		msleep(ihid->pdata.post_power_delay_ms);
+	else
+		usleep_range(1000, 5000);
+
+}
+
+static int __i2c_hid_set_power(struct i2c_client *client, int power_state)
 {
 	struct i2c_hid *ihid = i2c_get_clientdata(client);
 	int ret;
@@ -406,6 +429,23 @@ static int i2c_hid_set_power(struct i2c_
 		dev_err(&client->dev, "failed to change power setting.\n");
 
 set_pwr_exit:
+	if (!ret && power_state == I2C_HID_PWR_ON)
+		i2c_hid_power_delay(ihid);
+	return ret;
+}
+
+static int i2c_hid_set_power(struct i2c_client *client, int power_state)
+{
+	struct i2c_hid *ihid = i2c_get_clientdata(client);
+	int ret;
+
+	/*
+	 * Can be called from various places, including PM calls,
+	 * strict behaviour & delay.
+	 */
+	mutex_lock(&ihid->reset_lock);
+	ret=__i2c_hid_set_power(client, power_state);
+	mutex_unlock(&ihid->reset_lock);
 	return ret;
 }
 
@@ -423,25 +463,17 @@ static int i2c_hid_hwreset(struct i2c_cl
 	 */
 	mutex_lock(&ihid->reset_lock);
 
-	ret = i2c_hid_set_power(client, I2C_HID_PWR_ON);
+	ret = __i2c_hid_set_power(client, I2C_HID_PWR_ON);
 	if (ret)
 		goto out_unlock;
 
-	/*
-	 * The HID over I2C specification states that if a DEVICE needs time
-	 * after the PWR_ON request, it should utilise CLOCK stretching.
-	 * However, it has been observered that the Windows driver provides a
-	 * 1ms sleep between the PWR_ON and RESET requests and that some devices
-	 * rely on this.
-	 */
-	usleep_range(1000, 5000);
 
 	i2c_hid_dbg(ihid, "resetting...\n");
 
 	ret = i2c_hid_command(client, &hid_reset_cmd, NULL, 0);
 	if (ret) {
 		dev_err(&client->dev, "failed to reset device.\n");
-		i2c_hid_set_power(client, I2C_HID_PWR_SLEEP);
+		__i2c_hid_set_power(client, I2C_HID_PWR_SLEEP);
 	}
 
 out_unlock:
@@ -951,6 +983,20 @@ static inline int i2c_hid_of_probe(struc
 }
 #endif
 
+static int i2c_hid_regulator_enable(struct i2c_hid *ihid, struct i2c_client *client)
+{
+	int ret;
+
+	mutex_lock(&ihid->reset_lock);
+	ret = regulator_enable(ihid->pdata.supply);
+	if (ret < 0)
+		dev_err(&client->dev, "Failed to enable supply: %d\n", ret);
+	else
+		i2c_hid_power_delay(ihid);
+	mutex_unlock(&ihid->reset_lock);
+	return ret;
+}
+
 static int i2c_hid_probe(struct i2c_client *client,
 			 const struct i2c_device_id *dev_id)
 {
@@ -979,6 +1025,8 @@ static int i2c_hid_probe(struct i2c_clie
 	if (!ihid)
 		return -ENOMEM;
 
+	ihid->pdata.post_power_delay_ms = post_power_delay_ms_default;
+
 	if (client->dev.of_node) {
 		ret = i2c_hid_of_probe(client, &ihid->pdata);
 		if (ret)
@@ -1003,14 +1051,9 @@ static int i2c_hid_probe(struct i2c_clie
 		goto err;
 	}
 
-	ret = regulator_enable(ihid->pdata.supply);
-	if (ret < 0) {
-		dev_err(&client->dev, "Failed to enable regulator: %d\n",
-			ret);
+	ret = i2c_hid_regulator_enable(ihid, client);
+	if (ret < 0)
 		goto err;
-	}
-	if (ihid->pdata.post_power_delay_ms)
-		msleep(ihid->pdata.post_power_delay_ms);
 
 	i2c_set_clientdata(client, ihid);
 
@@ -1183,11 +1226,7 @@ static int i2c_hid_resume(struct device
 	int wake_status;
 
 	if (!device_may_wakeup(&client->dev)) {
-		ret = regulator_enable(ihid->pdata.supply);
-		if (ret < 0)
-			hid_warn(hid, "Failed to enable supply: %d\n", ret);
-		if (ihid->pdata.post_power_delay_ms)
-			msleep(ihid->pdata.post_power_delay_ms);
+		ret = i2c_hid_regulator_enable(ihid, client);
 	} else if (ihid->irq_wake_enabled) {
 		wake_status = disable_irq_wake(client->irq);
 		if (!wake_status)
