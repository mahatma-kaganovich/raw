Trying to support clustering (multiple access to cache file):
1) flock();
2) track & reload foreign cache changes (in cache write state).

--- a/smf-grey.c	2007-10-09 01:59:57.000000000 +0300
+++ b/smf-grey.c	2015-03-26 17:42:43.368960023 +0300
@@ -1,5 +1,6 @@
 /*  Copyright (C) 2005, 2006 by Eugene Kurmanin <me@kurmanin.info>
  *  Additional changes by Tim Kleingeld <thm-smf@takm.com>
+ *  Additional changes by Denis kaganovich (Dzianis Kahanovich) <mahatma@eu.by>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -242,6 +243,9 @@
 static sfsistat smf_data(SMFICTX *);
 #endif
 
+struct stat cache_stat;
+static void cache_load(char *file);
+
 static void strscpy(register char *dst, register const char *src, size_t size) {
     register size_t i;
 
@@ -410,7 +414,7 @@
     static int last_write_successful;
     static time_t last_rewrite;
     struct stat orig_stat;
-    FILE *dump = 0;
+    FILE *dump = 0, *dump0 = 0;
     unsigned long i, size = hash_size(HASH_POWER);
     cache_item *it, **parent;
     time_t curtime = time(NULL);
@@ -433,24 +437,33 @@
     }
     if (conf.always_rewrite) rewrite = 1;
 
+    if (dump0 = fopen(file, "a")) {
+	    flock(fileno(dump0), 1);
+	    if (fstat(fileno(dump0), &orig_stat)) {
+		rewrite = 1;
+	    } else {
+	        /* Rewritten by other node? Load */
+		if (orig_stat.st_size != cache_stat.st_size || orig_stat.st_mtime != cache_stat.st_mtime)
+			cache_load(file);
+	    }
+	    flock(fileno(dump0), 2);
+    } else {
+	rewrite = 1;
+    }
+
     /* If we're not rewriting, get the current length of the file so
      * we can truncate to that length if the write fails.
      */
     if (!rewrite) {
-	if (stat(file, &orig_stat)) {
-	    rewrite = 1;
-	} else {
-	    if (!(dump = fopen(file, "a"))) {
-		syslog(LOG_ERR, "[ERROR] failed to start append to %s: %m", file);
-		return;
-	    }
+	if (!(dump = dump0)) {
+	    syslog(LOG_ERR, "[ERROR] failed to start append to %s: %m", file);
 	}
-    }
-    if (rewrite) {
+    } else {
 	sprintf(newfile, "%s.new", file);
+	syslog(LOG_INFO, "[INFO] cache %s[.new] rewrite\n", newfile);
 	if (!(dump = fopen(newfile, "w"))) {
 	    syslog(LOG_ERR, "[ERROR] failed to create %s: %m", newfile);
-	    return;
+	    if (dump0) fclose(dump0);
 	}
     }
 
@@ -513,6 +526,7 @@
 		syslog(LOG_ERR, "[ERROR] failed to finish write to %s: %m", newfile);
 	    }
 	    unlink(newfile);
+	    if (dump0) fclose(dump0);
 	} else {
 	    if (!error) {
 		syslog(LOG_ERR, "[ERROR] failed to finish append to %s: %m", file);
@@ -525,11 +539,13 @@
     if (rewrite && rename(newfile, file)) {
 	syslog(LOG_ERR, "[ERROR] failed to rename %s: %m", newfile);
 	unlink(newfile);
+	if (dump0) fclose(dump0);
 	last_write_successful = 0;
 	return;
     }
     last_write_successful = 1;
     if (rewrite) {
+	if (dump0) fclose(dump0);
 	last_rewrite = curtime;
 	syslog(LOG_INFO, 
 	    "[INFO] cache rewrite of %d records completed in %d seconds\n",
@@ -548,8 +564,11 @@
     time_t curtime = time(0L);
 
     if (!(f = fopen(file, "r"))) {
+	syslog(LOG_INFO, "[INFO] cache %s open error: %m", file);
 	return;
     }
+    flock(fileno(f), 1);
+    fstat(fileno(f), &cache_stat);
     fgets(line, 1024, f);
     sscanf(line, "%*s %*s %d", &lines);
     if (lines < 4) {
@@ -588,6 +607,11 @@
 	it = cache[new.hash & hash_mask(HASH_POWER)];
 	while (it) {
 	    if (it->hash == new.hash && !strcmp(it->item, new.item)) {
+		/* Cluster concurrence */
+	        if (it->write_status != ST_WRITTEN && new.exptime < it->exptime) {
+		    SAFE_FREE(new.item);
+		    break;
+		}
 		new.next = it->next;
 		SAFE_FREE(it->item);
 		*it = new;
