#!/bin/sh
## pnp modules bootloader v0.14
## (c) Denis Kaganovich, under Anarchy license
## consume preprocessed /lib/modules/$KV/modules.alias

[[ -z "$TMPDIR" ]] && [[ -e /temp ]] && TMPDIR="/temp"

## millisecons
#SYS_FIND="/sys"
SYS_FIND=/sys/devices

single(){
	grep -qF ">$1<" "${PNP_TMP}.$2" && return 1
	echo ">$1<" >>"${PNP_TMP}.$2"
	return 0
}

mod(){
	local m m1 m2
	for m in $(echo -ne "$*" | sed -e 's/-/_/g') ; do
		$CHK && {
			single "$m" 0 || continue
		}
		modalias "$m" || {
			echo ">$m<" >>"${PNP_TMP}".4
			continue
		}
		if $FAST ; then
			case $PARALLEL in
			no) ;;
			0) ;;
			2)
				m2=""
				for m1 in $ALIAS ; do
					modparam $m1
					m2="$m2 $insmod "$m1" $PARAM ;"
				done
				eval "( ${m2%;} ) >/dev/null 2>&1 &"
				pids="$pids$! "
				continue
			;;
			*)
				pids="$pids$pid "
				pid=""
			;;
			esac
			
			for m1 in $ALIAS ; do
				modparam $m1
				wait $pid
				$cmd_quiet || echo -ne "\033[0G\033[0K$LCOUNT	$m1 $PARAM"
				$insmod "$m1" $PARAM >/dev/null 2>&1 &
				pid="$!"
			done
		else
		if ! [[ $PARALLEL == 0 ]] ; then
			pids="$pids$pid "
			pid=""
		fi
		for m1 in $ALIAS ; do
			m2=`echo -ne "$m1" | sed -e 's:.*/::g' -e 's/-/_/g' -e 's/\...$//'`
			[[ "$m" == "$m2" ]] || single "$m2" 0 || continue
			modparam $m1
			wait $pid
			$cmd_quiet || echo -ne "\033[0G\033[0K$LCOUNT	$m1 $PARAM"
			$insmod "$m1" $PARAM >/dev/null 2>&1 &
			pid="$!"
		done
		fi
	done
}

refresh(){
	LCOUNT="${LCOUNT}."
	echo -ne "\033[0G\033[0K$LCOUNT"
	local i j l
	
	wait $pid $pids
	pid=""
	pids=""

	if $FAST ; then
		sed -e 's%^\([^ 	]*\)[	 ]*.*$%>\1<%g' </proc/modules >"${PNP_TMP}".1
		cat `grep -ls "^DRIVER=" $(find $SYS_FIND -name uevent -print 2>/dev/null) </dev/null` </dev/null |grep "^DRIVER=\|^MODALIAS="|sed -e 's%-%_%g' -e 's%^.*=\(.*\)$%>\1<%g' >>"${PNP_TMP}".1
		if [[ "$(cat ${PNP_TMP}.1 /proc/partitions)" == "$(cat ${PNP_TMP}.2)" ]] ; then
			cat "${PNP_TMP}".3 "${PNP_TMP}".4 >"${PNP_TMP}".0
			return 1
		fi
		sort -u "${PNP_TMP}".1 >"${PNP_TMP}".0
		if ! $cmd_quiet ; then
			echo -ne "\033[0G\033[0K${BOLD}   ::${NORMAL}Loaded:"
			for i in $(sort -m ${PNP_TMP}.0 ${PNP_TMP}.3 | uniq -u) ; do
				[[ "$1" == "n" ]] && echo "$i" >>/nopnp.lst
				i="${i#>}"
				i="${i%<}"
				echo -ne " $i"
			done
			echo ""
		elif $cmd_unload && [[ "$1" == "n" ]] ; then
			sort -m ${PNP_TMP}.0 ${PNP_TMP}.3 | uniq -u >>/nopnp.lst
		fi
		cat "${PNP_TMP}".1 /proc/partitions >"${PNP_TMP}".2
		cp "${PNP_TMP}".0 "${PNP_TMP}".3
		cat "${PNP_TMP}".4 >>"${PNP_TMP}".0
		return 0
	fi

	l="\033[0G\033[0K${BOLD}   ::${NORMAL}Loaded:"
	while read i j; do
		single "$i" 1 || continue
		[[ "$1" == "n" ]] && echo "$i" >>/nopnp.lst
		$cmd_quiet || echo -ne "$l $i"
		l=""
	done </proc/modules
	cp "${PNP_TMP}".1 "${PNP_TMP}".0
	[[ -z "$l" ]] || return 1
	$cmd_quiet || echo ""
	return 0
}

count(){
	[[ "${LCOUNT#????????????????}" == "${LCOUNT}" ]] && return 0
	bad_msg "Deadloop?"
	return 1
}

load_aliases(){
	local i m
	while  count ; do
		if $FAST ; then
			# "sort -u" breaks bus order, but speedup boot
			mod $MDOLIST `sort -u $(find $SYS_FIND -name modalias -print 2>/dev/null) </dev/null 2>/dev/null'`
		else
		for i in `find $SYS_FIND -name modalias -print 2>/dev/null` ; do
			if [[ -e "$i" ]] && read m <"$i" ; then
				mod $m
			fi
		done
		mod $MDOLIST
		fi
		REORDER=""
		refresh || break
		[[ -n "$SDELAY" ]] && sleep "$SDELAY"
	done
}

mod_unload(){
	cd /
	if ! [[ -e ${NEW_ROOT}/lib/modules/$KV ]] ; then
		if ${cmd_autoinstall:-false} ; then
			echo -ne "(Installing /lib/modules/$KV)"
			mount -o remount,rw ${NEW_ROOT} &&
			cp -a /lib/modules/$KV ${NEW_ROOT}/lib/modules/$KV
		else
			echo -ne '(use "autoinstall" to install modules)'
		fi
	fi
	umount /lib
	local i l m=""
	l=""
	( $cmd_unload && [[ -n "$REAL_ROOT" ]] && [[ -e "/nopnp.lst" ]] ) || return
	echo -n "(removing unlocked modules"
	while read i; do
		i="${i#>}"
		l="${i%<} $l"
	done </nopnp.lst
	i="$(cat /proc/modules)"
	while [[ "$i" != "$m" ]]; do
		m="$i"
		echo -n "."
		rmmod $l >/dev/null 2>&1
		i="$(cat /proc/modules)"
	done
	echo -n ")"
}

pnp_options(){
	PARALLEL=0
	FAST=true
	cmd_nofb=false
	cmd_nopnp=false
	cmd_unload=false
	cmd_noraid=false
	cmd_real_init=/sbin/init
	local i v
	local p="*)PARAM='';;"
	while [[ -n "$*" ]] ; do
	i="$1"
	shift
	case "$i" in
	slow) FAST=false ;;
	parallel-startup) PARALLEL=1 ;;
	parallel-startup=*) PARALLEL="${i#*=}" ;;
	moduleparam=*)
		i="${i#*=}"
		p="*/${i%%:*}.ko)PARAM=\"${i#*:}\";;$p"
	;;
	md=*)	v="cmd_${i%%=*}"
		eval "$v=\"\$$v ${i#*=}\""
	;;
	*=*)	v="${i%%=*}"
		case "$v" in
		*.*) p="*/${i%%.*}.ko)PARAM=\"${i#*.}\";;$p" ;;
		*) export cmd_`echo "$v"|sed -e 's:[^a-zA-Z0-9_]:_:g'`="${i#*=}" ;;
		esac
	;;
	*.*) p="*/${i%%.*}.ko)PARAM=\"${i#*.}\";;$p" ;;
	*) export cmd_`echo "$i"|sed -e 's:[^a-zA-Z0-9_]:_:g'`=true ;;
	esac
	done
	$cmd_nofb && p="*/fb.ko)insmod=false;return 1;;$p"
	[[ -n "$cmd_noload" ]] && p="*/$(echo "$cmd_noload"|sed -e 's/,/.ko|*\//g').ko)insmod=false;return 1;;$p"
	echo "modparam(){
insmod=insmod
case \$1 in
1)insmod=${REORDER:-continue}
return 1;;
$p
esac
}" >/etc/modparam.sh
	$cmd_quiet && good_msg(){ return; }
}

link_dir(){
	local i
	for i in "$1"/*; do
		i="${i#$1}"
		if [[ -d "$2$i" ]]; then
			link_dir "$1$i" "$2$i"
		elif [[ "$i" != "/*" ]]; then
			ln -sf "$1$i" "$2$i"
		fi
	done
}

pnp_init(){
	eval "pnp_options $(cat /proc/cmdline)" # parsing
	if [[ -f /lib.loopfs ]]; then
		echo "









"
		for i in `find /lib/modules -name "*.ko"` ; do
			insmod $i
		done
		mount /lib.loopfs /lib -o loop
		link_dir /lib/root
	fi

	[[ -e /lib/modules/$KV/modules.dep ]] && return
	# pnponly
	rm /sbin/modprobe
	. /etc/modprobe.sh
	override_modprobe
}

override_modprobe(){
local f="/sbin/modprobe"
[[ -e $f ]] && ! ( grep -q "bug #197730" $f && rm /sbin/modprobe ) && return
echo '#!/bin/sh
. /etc/modprobe.sh
modprobe $*
exit $?' >$f
chmod 755 $f
echo "$f" >/proc/sys/kernel/modprobe
}

wild(){
	grep "$1" <modules.other|grep -v "${2:-x--}"|sed -e 's:.*/::g' -e 's/\...$//g'
}

cpufreq(){
	local l=""
	local CHK=false
	local w="$(wild $@)"
	for i1 in $w ; do
		mod $i1
		wait $pid $pids
		pid=""
		pids=""
		for i in `grep -ls "$i1" $(find /sys/devices/system/cpu -name scaling_driver 2>/dev/null) </dev/null | sed -e 's:/scaling_driver::g'` ; do
			read i2 <"$i/cpuinfo_transition_latency" >/dev/null 2>&1 || continue
			[[ "$i2" -gt "${l:=${i2}}" ]] && continue
			if [[ "$i2" == "$l" ]] ; then
				[[ "${freq#*${i1} }" == "$freq" ]] && freq="$freq$i1 "
			else
				freq=" $i1 "
			fi
		done
		rmmod $i1 >/dev/null 2>&1
	done
	rmmod $w >/dev/null 2>&1
}

cpufreq_gov(){
	local gov1=""
	for i1 in ${gov:-ondemand conservative} ; do
		mod cpufreq_${i1}
		wait $pid $pids
		pid=""
		pids=""
		for i in `find /sys/devices/system/cpu -name scaling_governor 2>/dev/null` ; do
			echo $i1 >"$i" 2>/dev/null
			read i2 <"$i"
			[[ "$i2" == "$i1" ]] || gov1="$gov1 $i"
		done
		rmmod cpufreq_${i1} >/dev/null 2>&1
		[[ -z "$gov1" ]] && break
	done
}

empty_hwopts(){
	local i
	for i in $* ; do
		echo -ne "" >/etc/modules/$i 2>/dev/null
	done
}

# params: part [loop]
# out: $DETECTED_LOOPS++, $DETECTED_ROOTS++
detect_part(){
	grep -qF ">$*<" "${PNP_TMP}.5" && return 0
	local l
	wait $pid $pids
	pid=""
	pids=""
	$cmd_quiet || echo -ne "\033[0G\033[0K$LCOUNT	Inspecting: $1"
	mkdir /DETECT_ROOT || return 1
	mount -o ro "$1" /DETECT_ROOT >/dev/null 2>&1 || {
		rmdir /DETECT_ROOT
		return 1
	}
	echo ">$*<" >>"${PNP_TMP}.5"
	[[ "${2:-false}" != false ]] && for l in $( {
		if [[ "$2" == true ]]; then
			blkid ${LOOPS_}
		else
			blkid $2
		fi
		} | sed -e 's%^\(.*:\).* TYPE="\([^"]*\)".*$%\1\2%g'
	    ) ; do
		DETECTED_LOOPS="$DETECTED_LOOPS $1:${l#/DETECT_ROOT/}"
		fs="${l#:*}"
		case "$fs" in
		ext2) LOOPTYPE=normal ;;
		*) LOOPTYPE="$fs" ;;
		esac
		mod $fs # loop
	done
	[[ -e "/DETECT_ROOT/$cmd_real_init" ]] && grep -q "^$1[ 	]*/[ 	]" /DETECT_ROOT/etc/mtab 2>/dev/null && DETECTED_ROOTS="$DETECTED_ROOTS $1"
#	[[ -e "/DETECT_ROOT/$cmd_real_init" ]] && DETECTED_ROOTS="$DETECTED_ROOTS $1"
	umount /DETECT_ROOT >/dev/null 2>&1
	rmdir /DETECT_ROOT
}

part_(){
	( blkid $1 || blkid -t "$1" || findfs "$1" || busybox findfs "$1" ) 2>/dev/null | sed -e 's:^.* TYPE="swap".*$::g' -e 's/:.*$//g'
}

detect_root(){
	local i d="${cmd_detect_root:-false}" l="$cmd_loop" fs
	[[ "$d" == true ]] && d=""
	if [[ "$d" != false ]]; then
		# if real_root & loop hard-defined - don't probe other loops
		[[ -n "$REAL_ROOT" ]] && [[ "${l:-true}" != true ]] && l=false
		# if real_root & loop hard-defined - probe all loops
#		[[ -n "$REAL_ROOT" ]] && [[ "${l:-true}" != true ]] && l=true
		for i in `part_ "$d"`; do
			case "$i" in
			/dev/loop0) ;;
			*) detect_part "$i" "$l" ;;
			esac
		done
	fi
	if [[ -n "$REAL_ROOT" ]] && [[ "${cmd_loop:-false}" != false ]]; then
		detect_part "$(part_ "$REAL_ROOT")" "$cmd_loop"
	fi
}

dhcp_get(){
	local i r=''
	for i in `busybox dmesg | grep rootserver | sed -e "s/,/ /g"`; do
		if [[ "`echo $i | sed -e "s/=/ /g" | cut -d " " -f 1`" == "$1" ]]; then
			r="`echo "$i" | sed -e "s/=/ /g" | cut -d " " -f 2`"
			# FIXME: first value will be more balanced, but last - actual in longrun
			break
		fi
	done
	echo -ne "$r"
}

# modifyed genkernel's function to support other network filesystems (/dev/<filsystem>)
findnfsmount() {
	grep -q "[ 	]${NFSLIKE_FS:=nfs}\$" /proc/filesystems || return 1
	if [[ -n "$IP" ]] || busybox udhcpc -n -T 15 -q ; then
		[ -e /rootpath ] && cmd_nfsroot=`cat /rootpath`

		if [[ -z "${cmd_nfsroot:=$(dhcp_get rootserver):$(dhcp_get rootpath)}" ]]; then
			bad_msg "The DHCP Server did not send a valid root-path."
			bad_msg "Please check your DHCP setup, or provide a nfsroot=<...> parameter."
		else
			local local o m="$NEW_ROOT"
			[[ "$CDROOT" != '0' ]] && m="$m/mnt/cdrom"
			good_msg "Attempting to mount $NFSLIKE_FS on $cmd_nfsroot into $m"
			for o in "ro,nolock,rsize=1024,wsize=1024" "ro,nolock" "ro"; do
				if mount -t $NFSLIKE_FS -o $o $cmd_nfsroot $m ; then
					# FIXME: Need to start portmap and the other rpc daemons in
					# order to remount rw.
					REAL_ROOT="/dev/nfs"
					return 0
				fi
			done
			bad_msg "$NFSLIKE_FS Mounting failed. Is the path correct ?"
		fi
	fi
	return 1
}

msg_(){
	wait $pid $pids
	pid=""
	pids=""
	if $cmd_quiet; then
		echo -ne "\033[0G"
	else
		echo -ne "\033[0G\033[0K"
		[[ -n "$*" ]] && good_msg "$*"
	fi
}

detect_fs(){
	# dmraid/lvm/evms unsure
	local i m="" md="$USE_MDADM" dm="$USE_DMRAID_NORMAL" t="" nfs="$cmd_nfsroot" lvm="$USE_LVM_NORMAL" evms="$USE_EVMS_NORMAL"
	for i in $( {
			if [[ "${cmd_detect_root:-true}" == true ]]; then
				blkid
			else
				blkid $cmd_detect_root || blkid -t $cmd_detect_root || echo -e "$cmd_detect_root"
				[[ -n "$REAL_ROOT" ]] && [[ "$REAL_ROOT" != "$cmd_detect_root" ]] && ( blkid $REAL_ROOT || blkid -t $REAL_ROOT || echo -e "$REAL_ROOT" )
			fi
	    } 2>/dev/null | sed -e 's:^.* TYPE="\([^"]*\)".*$:\1:g' | sort -u ); do
		case $i in
		linux_raid_member|mdraid|/dev/md*) : md=1 ;; # use right blkid
		/dev/mapper*|/dev/dm*) : dm=1 ;;
		EVMS*|evms*)
			evms=1
			dm=1
		;;
		LVM*|lvm*)
			lvm=1
			dm=1
		;;
		*raid*)
			m="$m $(wild "/$i/\|raid") $i"
			dm=1
		;;
		/dev/*)
			i="${i#/dev/}"
			m="$m $i"
			NFSLIKE_FS="$i"
			[[ "$REAL_ROOT" == "$i" ]] && REAL_ROOT=/dev/nfs # compat
		;;
		swap) ;;
		*) m="$m $(wild "/$i/") $i" ;;
		esac
	done
	[[ -n "$dm" ]] && m="$m dm-mod"
	# FIXME: IMHO it will be loaded after dmraid failure
#	[[ -n "$dm" ]] && m=$m $(wild "/md/dm-\|raid_class")"
	mod $m
	if [[ -n "$evms" ]]; then
		msg_ "Activating EVMS"
		if evms_activate ; then
			USE_EVMS_NORMAL_=""
			lvm=""
			USE_LVM_NORMAL=""
			USE_LVM_NORMAL_=""
		fi
	fi
	if [[ -n "$lvm" ]]; then
		msg_ "Activating LVM"
		if vgscan --ignorelockingfailure --mknodes 2>/dev/null ; then
			sleep 2
			vgchange -ay --ignorelockingfailure 2>/dev/null
			USE_LVM_NORMAL_=""
			evms=""
			USE_EVMS_NORMAL=""
			USE_EVMS_NORMAL_=""
		fi
	fi
	for i in $cmd_md ; do
		set `echo "$i"|sed -i -e 's:,: :g'`
		i="$1$2$3$4"
		if [[ -n "$5" ]] && [[ "${i##*/dev/}" == "$i" ]]; then
			mod "raid$2"
			i="$1 --level=$2 --chunk=$3"
			shift 4
			i="--build /dev/md$i"
		else
			mod $(wild "/md/raid")
			i="$1"
			shift
			[[ "${i#d}" != "$i" ]] && i="${i#d} --run"
			i="--assemble /dev/md$i"
		fi
		msg_
		mdadm $i --raid-devices=$# $*
	done
	if [[ -n "$md$dm" ]]; then
		# maybe dm wrong here, but try
		if [[ -e '/etc/mdadm.conf' ]]; then
			mod `( grep " level=" /etc/mdadm.conf || ( mdadm --examine --scan -v|grep " level=" ) ) | sed -e 's:^.* level=\([^ ]*\) .*$:\1:g' | sort -u`
		else
			mdadm --examine --scan -v >/etc/mdadm.conf
			mod `grep " level=" /etc/mdadm.conf | sed -e 's:^.* level=\([^ ]*\) .*$:\1:g' | sort -u`
		fi
		if [[ -n "$md" ]]; then
			msg_
			# busybox | mdadm | all raid modules
			( $cmd_noraid || mdadm --assemble || mdadm --assemble --scan ||
				( mod $(wild "/md/") ; ( mdadm --assemble || mdadm --assemble --scan ) ) ) && USE_MDADM_=""
		fi
	fi
	if [ -e /sbin/dmraid -o -e /usr/sbin/dmraid ]; then
		if $cmd_noraid; then
			t=t
			msg_ "Testing Device-Mapper RAID(s)"
		else
			msg_ "Activating Device-Mapper RAID(s)"
		fi
		if dmraid -ay$t ${DMRAID_OPTS} >/dev/null ; then
			USE_DMRAID_NORMAL_=""
		else
			mod $(wild "/md/\|raid")
			msg_
			dmraid -ay$t ${DMRAID_OPTS} && USE_DMRAID_NORMAL_=""
		fi
	fi
	detect_root
	[ -e /bin/blkid -o -e /sbin/blkid ] && empty_hwopts fs
	empty_hwopts ataraid dmraid evms lvm mdadm
	return 0
}

gentoo_compat_hwopts(){
	local i i1
	for i1 in ${MY_HWOPTS} ; do
		if [[ -e "/etc/modules/$i1" ]] ; then
			for i in `cat /etc/modules/$i1` ; do
				grep -q "^$i\$" "modules.pnp" || mod "$i"
			done
		else
			mod $(wild "/${i1}[./]")
		fi
	done
}

load_hand_made(){
	## some hand-made autoloads
	$cmd_nofb || [[ -z "$(cat /proc/fb 2>/dev/null)" ]] || mod fbcon
	while read i i1 ; do
		case $i in
#		usual_tables) mod usb_storage ;; # on demand
		usbcore) mod usb_storage ;; # user-frendly
#		thermal_sys) mod fan ;;
		esac
	done </proc/modules
	${cmd_nopowersave:-false} && return
	# frost. save your silicon (and power)
	# autoload cpufreq driver in price of at least one more unload
	# just speedup probing by vendor
	case "$(grep "^vendor_id" /proc/cpuinfo)" in
	*AMD*)
		cpufreq powernow
		: ${gov:=conservative ondemand}
	;;
	*Intel*) cpufreq acpi-cpufreq ;;
	esac
	[[ -z "$freq" ]] && cpufreq cpufreq "drivers/cpufreq/\|powernow"
	mod $freq
	cpufreq_gov
	rmmod freq_table >/dev/null 2>&1
	for i in /sys/devices/system/cpu/sched_*_power_savings ; do
		[[ -e "$i" ]] && echo 2 >$i 2>/dev/null
	done
}

load_misc(){
	detect_fs
	# do: loadall[=...] or process MY_HWOPTS
	for i in $cmd_loadall ; do
		[[ "$i" == 'true' ]] && i=''
		i1="${i%%:*}"
		i2="${i#*:}"
		[[ -z "$i1" ]] && i1=".*"
		# default: exclude slow probe, fatal to unload, etc
		[[ "$i2" == "$i" ]] && i2='/tcrypt.ko\|/paride/\|/media/\|/sound/\|/microcode\.\|/isdn/\|/net/\|/video/'
		mod $(wild "$i1" "$i2")
	done
	[[ -z "$cmd_loadall" ]] && [[ "$NODETECT" != '1' ]] && gentoo_compat_hwopts # deprecated
}

set_root_loop(){
	set 1 `echo "$1"|sed -e 's/:/ /g'`
	REAL_ROOT="$2"
	LOOP="$3"
	LOOPTYPE="$4"
}

syspnp(){
	[[ -e "/lib/modules/${KV}/modules.alias.sh" ]] || return
	$cmd_nopnp && return
	# +some compats
	local PNP_TMP="${TMPDIR}/pnp.found" NOTLOADED="" CHK=true i i1 i2 gov="" freq="" pid="" pids="" LCOUNT="" REORDER=break USE_MDADM_="${USE_MDADM:=$cmd_domdadm}" USE_DMRAID_NORMAL_="${USE_DMRAID_NORMAL:=$cmd_dodmraid}" USE_EVMS_NORMAL_="${USE_EVMS_NORMAL:=$cmd_doevms}" USE_LVM_NORMAL_="${USE_LVM_NORMAL:=$cmd_dolvm}" LOOPS_=""
	[[ "${USE_DMRAID_NORMAL:-true}" != true ]] && DMRAID_OPTS="$USE_DMRAID_NORMAL"
	: ${REAL_ROOT:=$cmd_real_root}
	for i in ${LOOPS:-"/*"}; do
		LOOPS_="${LOOPS_} /DETECT_ROOT$i"
	done

	good_msg "Searching pnp"
	if [[ -e /lib/modules/$KV/modules.dep ]]; then
		# else - pnponly/init
		. /etc/modprobe.sh
		override_modprobe
	fi
	for i in 0 1 2 3 4 5; do
		echo -ne "" >"${PNP_TMP}.$i"
	done

	empty_hwopts firewire net pata pcmcia sata scsi usb
	if $FAST; then
		# this way too fast
		$cmd_unload && refresh n
		while count ; do
			if [[ -n "$REORDER" ]]; then
				# first pass - strict bus order
				mod $MDOLIST `cat $(find $SYS_FIND -name modalias -print 2>/dev/null|sort) </dev/null 2>/dev/null|uniq'`
				REORDER=""
				wait $pid $pids
				pid=""
				pids=""
				load_hand_made
				wait $pid $pids
				pid=""
				pids=""
			else
				mod $MDOLIST `sort -u $(find $SYS_FIND -name modalias -print 2>/dev/null) </dev/null 2>/dev/null'`
			fi
			$cmd_unload && refresh
			load_misc
			refresh n || break
		done
	else
		refresh n
		if [[ -n "$MDOLIST" ]]; then
			mod $MDOLIST
			refresh
		fi
		load_aliases
		load_hand_made
		refresh
		while count ; do
			load_misc
			refresh n || break
			load_aliases
		done
	fi

	MY_HWOPTS=""
	MDOLIST=""
	USE_MDADM="${USE_MDADM_}"
	USE_DMRAID_NORMAL="${USE_DMRAID_NORMAL_}"
	USE_LVM_NORMAL="${USE_LVM_NORMAL_}"
	USE_EVMS_NORMAL="${USE_EVMS_NORMAL_}"

	echo -ne "\033[0G\033[0K"

	# assign detected root/loop
	if [[ -z "$REAL_ROOT" ]]; then
		DETECTED_ROOTS="${DETECTED_ROOTS# }"
		DETECTED_LOOPS="${DETECTED_LOOPS# }"
		[[ "${DETECTED_ROOTS#* }" == "$DETECTED_ROOTS" ]] && DETECTED_ROOT="$DETECTED_ROOTS"
		[[ "${DETECTED_LOOPS#* }" == "$DETECTED_LOOPS" ]] && DETECTED_LOOP="$DETECTED_LOOPS"
		[[ "${cmd_loop:-true}" == true ]] && REAL_ROOT="$DETECTED_ROOT"
		( [[ "$cmd_loop" != true ]] || [[ -z "$DETECTED_ROOTS" ]] ) && [[ -z "$REAL_ROOT" ]] && set_root_loop "$DETECTED_LOOP"
		if [[ -z "$REAL_ROOT" ]]; then
			[[ -n "$DETECTED_ROOTS" ]] && bad_msg "Detected possible root devices: $DETECTED_ROOTS"
			[[ -n "$DETECTED_LOOPS" ]] && bad_msg "Detected loopbacks: $DETECTED_LOOPS"
		fi
	fi

	good_msg "Boot time: $(cat /proc/uptime)"
	if [[ -n "${NOTLOADED}" ]] ; then
		good_msg "Not loaded:$NOTLOADED"
		# try again
		MDOLIST="$NOTLOADED"
	fi
	rm "${PNP_TMP}".?
#	cd /
}

# minimalistic. debug
if [[ -z "$KV"  ]] && ! [[ -e /proc/version ]]; then
NEW_ROOT="/newroot"
NEW_ROOT_TYPE=auto
CDROOT=0
good_msg(){
echo "$*"
}
bad_msg(){
echo "! $*"
}
mount -t proc proc /proc
mount -o remount,rw,noatime / 2>/dev/null
/bin/busybox --install -s
KV=`uname -r`
pnp_init
mount -t sysfs /sys /sys
echo /sbin/mdev >/proc/sys/kernel/hotplug
syspnp
cd /sys
mdev -s
cd /
while true; do
	if [[ -n "$REAL_ROOT" ]] && mkdir "$NEW_ROOT" 2>/dev/null ; then
		if [[ -z "$NFSLIKE_FS" ]] || ! findnfsmount; then
			mount -t "$NEW_ROOT_TYPE" -o ro "$REAL_ROOT" "$NEW_ROOT" || rmdir "$NEW_ROOT"
		fi
		[[ "$NEW_ROOT" == /dev/nfs ]] && [[ -e /newroot ]] && NEW_ROOT="/newroot"
		if [[ -e "$NEW_ROOT" ]] && [[ -n "$LOOP" ]]; then
			LOOP_ROOT="$NEW_ROOT/mnt/livecd"
			if ! [[ -e "$LOOP_ROOT" ]]; then
				LOOP_ROOT="$NEW_ROOT.loop"
				mkdir "$LOOP_ROOT"
			fi
			if ! ( [[ -e "$LOOP_ROOT" ]] && mount -o loop,ro "/newroot/$LOOP" "$LOOP_ROOT" && [[ -e "$LOOP_ROOT$cmd_real_init" ]] ) ; then
				umount "$LOOP_ROOT"
				rmdir "$LOOP_ROOT"
				umount "$NEW_ROOT"
				rmdir "$NEW_ROOT"
				rmdir "$LOOP_ROOT"
				LOOP_ROOT=""
			fi
		fi
	fi
	if [[ -n "$LOOP_ROOT" ]] && [[ -e "$LOOP_ROOT" ]]; then
		mod_unload
		umount /sys
		umount /proc
		[[ -e /lib.loopfs ]] && mkdir /lib.rc && mount -o loop /lib.loopfs /lib.rc && link_dir /lib.rc /lib
		link_dir "$LOOP_ROOT"
		exec "$cmd_real_init" "$cmd_init_opts"
	elif [[ -e "$NEW_ROOT" ]]; then
		mod_unload
		umount /sys
		umount /proc
		exec /sbin/switch_root -c /dev/console "$NEW_ROOT" "$cmd_real_init" "$cmd_init_opts"
	else
		bad_msg "failed to mount root"
		read -p "Enter root partition or 'shell':" REAL_ROOT
		set_root_loop "$REAL_ROOT"
		[[ "$REAL_ROOT" == shell ]] || continue
	fi
	bad_msg "failed to switch root"
	sh
done
fi
