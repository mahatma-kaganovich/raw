#!/bin/sh
## pnp modules bootloader v0.7
## (c) Denis Kaganovich, under Anarchy license
## consume preprocessed /lib/modules/$KV/modules.alias

MODUNLOAD=false
[[ -z "$KV" ]] && KV=`uname -r`
[[ -z "$TMPDIR" ]] && [[ -e /temp ]] && TMPDIR="/temp"

single(){
	grep -qF ">$1<" "${PNP_TMP}.$2" && return 1
	echo ">$1<" >>"${PNP_TMP}.$2"
	return 0
}

mod(){
	local m m1 m2
	for m in $(echo -ne "$*" | sed -e 's/-/_/g') ; do
		single "$m" 0 || continue
		alias2 "$m" || continue
		if $FAST ; then
			case $PARALLEL in
			no) ;;
			0) ;;
			2)
				m2=""
				for m1 in $ALIAS ; do
					modparam $m1
					m2="$m2 insmod "$m1" $PARAM ;"
				done
				eval "( ${m2%;} ) >/dev/null 2>&1 &"
				pids="$pids$! "
				continue
			;;
			*)
				pids="$pids$pid "
				pid=""
			;;
			esac
			
			for m1 in $ALIAS ; do
				modparam $m1
				wait $pid
				$QUIET || echo -ne "\033[0G\033[0K$LCOUNT	$m1 $PARAM"
				insmod "$m1" $PARAM >/dev/null 2>&1 &
				pid="$!"
			done
		else
		if ! [[ $PARALLEL == 0 ]] ; then
			pids="$pids$pid "
			pid=""
		fi
		for m1 in $ALIAS ; do
			m2=`echo -ne "$m1" | sed -e 's:.*/::g' -e 's/-/_/g' -e 's/\...$//'`
			[[ "$m" == "$m2" ]] || single "$m2" 0 || continue
			modparam $m1
			wait $pid
			$QUIET || echo -ne "\033[0G\033[0K$LCOUNT	$m1 $PARAM"
			insmod "$m1" $PARAM >/dev/null 2>&1 &
			pid="$!"
		done
		fi
	done
}

refresh(){
	LCOUNT="${LCOUNT}."
	echo -ne "\033[0G\033[0K$LCOUNT"
	local i j l
	
	wait $pid $pids
	pid=""
	pids=""

	if $FAST ; then
		sed -e 's%\([^ 	]*\)[	 ]*.*$%>\1<%g' </proc/modules | sort >"${PNP_TMP}".1
		cat `grep -l "^DRIVER=" $(find /sys -name uevent -print 2>/dev/null) 2>/dev/null` |grep "^DRIVER=\|^MODALIAS="|sort -u|sed -e 's%-%_%g' -e 's%^.*=\(.*\)$%>\1<%g' >>"${PNP_TMP}".1
		[[ "$(cat ${PNP_TMP}.1)" == "$(cat ${PNP_TMP}.2)" ]] && return 1
		cp "${PNP_TMP}".1 "${PNP_TMP}".2
		if ( $MODUNLOAD && [[ "$1" == "n" ]] ) || ! $QUIET ; then
			$QUIET || echo -ne "\033[0G\033[0K${BOLD}   ::${NORMAL}Loaded:"
			sed -i -e 's%^>\(.*\)<$%\1%g' "${PNP_TMP}".1
			while read i ; do
				grep -qF ">$i<" "${PNP_TMP}".3 && continue
				[[ "$1" == "n" ]] && echo "$i" >>/nopnp.lst
				$QUIET || echo -ne " $i"
			done <"${PNP_TMP}".1
			$QUIET || echo ""
		fi
		cp "${PNP_TMP}".2 "${PNP_TMP}".0
		cp "${PNP_TMP}".2 "${PNP_TMP}".3
		return 0
	fi

	l="\033[0G\033[0K${BOLD}   ::${NORMAL}Loaded:"
	while read i j; do
		single "$i" 1 || continue
		[[ "$1" == "n" ]] && echo "$i" >>/nopnp.lst
		$QUIET || echo -ne "$l $i"
		l=""
	done </proc/modules
	cp "${PNP_TMP}".1 "${PNP_TMP}".0
	[[ -z "$l" ]] || return 1
	$QUIET || echo "" 
	return 0
}

count(){
	[[ "${LCOUNT#????????????????}" == "${LCOUNT}" ]] && return 0
	bad_msg "Deadloop?"
	return 1
}

load_aliases(){
	local i m
	while  count ; do
		if $FAST ; then
			mod `cat $(find /sys -name modalias -print 2>/dev/null) 2>/dev/null|sort -u'`
		else
		for i in `find /sys -name modalias -print 2>/dev/null` ; do
			if [[ -e "$i" ]] && read m <"$i" ; then
				mod $m
			fi
		done
		fi
		refresh || break
		mod $MDOLIST
		[[ -n "$SDELAY" ]] && sleep "$SDELAY"
	done
}

mod_unload(){
	local i l
	l=""
	( $MODUNLOAD && [[ -n "$REAL_ROOT" ]] && [[ -e "/nopnp.lst" ]] ) || return
	echo -n "(removing unlocked modules)"
	while read i; do
		l="$i $l"
	done </nopnp.lst
	rmmod $l >/dev/null 2>&1
	rmmod `cat /nopnp.lst` >/dev/null 2>&1
}

pnp_options(){
	local i
	local p="*) PARAM='' ;;
esac
}"
	while [[ -n "$*" ]] ; do
	i="$1"
	shift
	case "$i" in
	quiet) $FAST || good_msg "PNP: quiet mode"; eval 'good_msg(){ return; }'; QUIET=true ;;
	nofb) NOFB=true ;;
	nopnp) NOPNP=true ;;
	unload) MODUNLOAD=true ;;
	loadall) LOADALL="all" ;;
	loadall=*) LOADALL="${i#*=}" ;;
	slow) FAST=false ;;
	parallel-startup) PARALLEL=1 ;;
	parallel-startup=*) PARALLEL="${i#*=}" ;;
	moduleparam=*)
		i="${i#*=}"
		p="*/${i%%:*}.ko) PARAM=\"${i#*:}\" ;;
$p"
	;;
	esac
	done
	p="modparam(){
case \$1 in
$p"
	echo "$p" >/modparam.sh
}

ifmod(){
	local i
	for i in $* ; do
		grep -qF ">$i<" "${PNP_TMP}".0 || return 1
	done
	return 0
}

override_modprobe(){
local f="/sbin/modprobe"
[[ -e $f ]] && ! grep -q "bug #197730" $f && return
echo '#!/bin/sh
KV=`uname -r`
cd /lib/modules/$KV
. /modparam.sh
. ./modules.alias.sh
while [[ "${1#-}" != "$1" ]] ; do
	shift
done
r=1
alias2 "$(echo -ne "$1" | sed -e s/-/_/g)" && for i in $ALIAS ; do
	modparam $i
	insmod $i $PARAM
	r=$?
done
exit $r' >$f
chmod 755 $f
echo "$f" >/proc/sys/kernel/modprobe
}

wild(){
	WILD=$(grep "$1" <modules.other|grep -v "$2"|sed -e 's:.*/::g' -e 's/\...$//g')
}

cpufreq(){
	wild $@ x--
	local l=""
	for i1 in $WILD ; do
		mod $i1
		wait $pid $pids
		pid=""
		pids=""
		for i in `grep -l "$i1" $(find /sys/devices/system/cpu -name scaling_driver 2>/dev/null) 2>/dev/null | sed -e 's:/scaling_driver::g'` ; do
			read i2 <"$i/cpuinfo_transition_latency" >/dev/null 2>&1 || continue
			[[ "$i2" -gt "${l:=${i2}}" ]] && continue
			if [[ "$i2" == "$l" ]] ; then
				[[ "${freq#*${i1} }" == "$freq" ]] && freq="$freq$i1 "
			else
				freq=" $i1 "
			fi
		done
		rmmod $i1 >/dev/null 2>&1
	done
}

cpufreq_gov(){
	local gov1=""
	for i1 in $gov ; do
		mod cpufreq_${i1}
		wait $pid $pids
		pid=""
		pids=""
		for i in `find /sys/devices/system/cpu -name scaling_governor 2>/dev/null` ; do
			read i2 <"$i"
			[[ "$i2" == "$i1" ]] || gov1="$gov1 $i"
		done
		rmmod cpufreq_${i1} >/dev/null 2>&1
		[[ -z "$gov1" ]] && break
	done
}

syspnp(){
	local PNP_TMP="${TMPDIR}/pnp.found"
	local NOTLOADED=""
	local NOFB=false
	local NOPNP=false
	local QUIET=false
	local LOADALL=""
	local FAST=true
	local PARALLEL=0
	local pid=""
	local pids=""

	[[ -e "/lib/modules/${KV}/modules.alias.sh" ]] || return
	eval "pnp_options $(cat /proc/cmdline)" # parsing
	$NOPNP && return
	. /modparam.sh
	cd "/lib/modules/${KV}"
	local i i1 i2 gov
	good_msg "Searching pnp"
	for i in 0 1 2 3 ; do
		echo -ne "" >"${PNP_TMP}.$i"
	done
	refresh n
	override_modprobe
	LCOUNT=""
	. "./modules.alias.sh"

	if [[ -n "$MDOLIST" ]]; then
		mod $MDOLIST
		refresh
	fi
	single usb_storage 0
	load_aliases
	$NOFB || mod fbcon

	## some hand-made autoloads

	ifmod usbcore && mod usb_storage # user-frendly
#	ifmod usual_tables && mod usb_storage # on demand
	# frost. save your silicon (and power)
	# autoload cpufreq driver in price of at least one more unload
#	ifmod thermal_sys && mod fan
	local freq=""
	if grep -q "^vendor_id.*AMD" /proc/cpuinfo ; then
		cpufreq "powernow\|acpi-cpufreq"
		gov="conservative ondemand"
	else
		cpufreq "acpi-cpufreq"
		gov="ondemand conservative"
	fi
	[[ -z "$freq" ]] && cpufreq cpufreq
	mod $freq
	cpufreq_gov
	rmmod freq_table >/dev/null 2>&1

	refresh
#	good_msg "Filtering pnp modules"
	while count ; do
		local NODETECT
		if [[ -n "$LOADALL" ]] ; then
			for i in $LOADALL ; do
				[[ "$i" == 'all' ]] && i=''
				i1="${i%%:*}"
				i2="${i#*:}"
				[[ -z "$i1" ]] && i1=".*"
				# default: exclude slow probe, fatal to unload, etc
				[[ "$i2" == "$i" ]] && i2='/tcrypt.ko\|/paride/\|/media/\|/sound/\|/microcode\.\|/isdn/\|/net/\|/video/'
				wild "$i1" "$i2"
				mod $WILD
			done
			NODETECT=1
		fi
			# NODETECT: old behaviour
		[[ "${NODETECT}" != '1' ]] && for i1 in ${MY_HWOPTS} ; do
			[[ -e "/etc/modules/$i1" ]] && for i in `cat /etc/modules/${i1}` ; do
				grep -q "^$i\$" "modules.pnp" && continue
				mod "$i"
			done
		done
		refresh n || break
		mod $MDOLIST
		load_aliases
	done
	MY_HWOPTS=""
	MDOLIST=""
	echo -ne "\033[0G\033[0K"
	$QUIET || good_msg "Boot time: $(cat /proc/uptime)"
	if [[ -n "${NOTLOADED}" ]] ; then
		good_msg "Not loaded:$NOTLOADED"
		# try again
		MDOLIST="$NOTLOADED"
	fi
	rm "${PNP_TMP}".?
}

[[ "$1" == "init" ]] && syspnp $* # debug
