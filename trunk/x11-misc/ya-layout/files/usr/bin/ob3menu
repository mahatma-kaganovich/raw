#!/usr/bin/perl
# (c) Denis Kaganovich, Anarchy or GPLv2
# OpenBox3 pipe menu v0.6
# ob3menu {--<command> {params}}
# 	--slow [<path/to/rc.xml> [X Y]]
#	--autostart {profile}
#	--include {menu to include}
#	--profile {profile}
#	--mime <mime.sh> {dirs}
#	--launcher <~/.cache/ya/desk.+.jpg> <~/.cache/ya/desk-sh> [<geometry|,> [<wallpaper+compositor_options>]]
#		geometry = x,y,vert?,xx,yy,spliceX,spliceY,left?,bottom?
#	--tint2 [<config>]
#	--dock
# "--slow" - +keybinds, 3.5.0+ menu icons, better with cache.
#
# OnlyShowIn is specified, but I newer want it. But you can think else.
# Consensus: listed as "? ..."
#
# Launcher: starting to do fullscreen trendy "desktop", I see I don't need it, but need
# small launcher near tint2... So, fast partial...

$SIG{__DIE__}=sub{
return if(!exists($ENV{DBUS_SESSION_BUS_ADDRESS}));
print STDERR ($e=join('',"$0: ",@_));
exec('/usr/bin/notify-send','-t',6000,$e);
};

my (%ico,%key,%cat,%cat1,%dir,@prof,$prof);
#$misc='Other';
$misc='misc';
%base=%cc=(
# http://standards.freedesktop.org/menu-spec/menu-spec-1.1.html
'AudioVideo'=>10000,
'Audio'=>10000,
'Video'=>10000,
'Development'=>10000,
'Education'=>10000,
'Game'=>10000,
'Graphics'=>10000,
'Network'=>10000,
'Office'=>10000,
'Settings'=>10000,
'System'=>10000,
'Utility'=>10000,
#
'Autostart'=>0,
'Other'=>-1,
$misc=>-1,
);
%cname=(
	'Multimedia'=>'AudioVideo',
	'Utility'=>'Accessories',
	'Accessories'=>'Utility',
	'Other'=>'Application',
	'InternetAndNetwork'=>'Network',
);
%xml_=('<'=>'lt','>'=>'gt',"'"=>'apos','"'=>'quot','&'=>'amp');
$xml_='<>\'"&';
%notify=(
	'true'=>'<startupnotify><enabled>yes</enabled></startupnotify>',
	'false'=>'<startupnotify><enabled>no</enabled></startupnotify>'
);
%ico_=(
	'fs'=>['mount-point'],
	'umount'=>['usbpendrive_unmount','gdu-unmount'],
	'mount'=>['xfce-mount','gdu-mount'],
);
@conf=(['showIcons'],['dock',['position'],['direction']]);
$id=0;

for(@ARGV){
	if($_=~s/^--//){
		undef $P{$i=$_};
	}else{
		push(@{$P{$i}},$_);
	}
}

for($ENV{LANG}=~/([a-zA-Z0-9]+)?(_\w+)?(\.[\w-]+)?(\@\w+)?/){
	$lang.='(?:'.quotemeta($_).')?' if(defined($_));
}
$lang='(?:\['.$lang.'\])?' if($lang);

@path=split(/:/,$ENV{PATH});

if(exists($P{profile})){
	$prof=join('|',@{$P{profile}});
}elsif($prof=$ENV{YA_PROFILE}){
	$prof=~s/[, ]+/|/g;
}

sub eXist{
	if(index($_[0],'/')>=0){
		stat($_[0]);
		return(-x _ && -f _);
	}
	for(@path){
		stat("$_/$_[0]");
		return 1 if(-x _ && -f _);
	}
	0;
}

sub icons{
	opendir(my $D,$_[0])||return;
	my @d=readdir($D);
	closedir($D);
	for(@d){
		if(my ($i,$j)=$_=~/^(.*)\.(...)$/){
			$ico{$i}=$ico{$_}=$_[0].$_ if($j && $j ne 'svg');
		}elsif(!($_=~/^\.|scalable/)){
			icons("$_[0]$_/");
		}
	}
}

sub ico{
	for(@_){
		for(@{$ico_{$_}},$_){
			return " icon='$ico{$_}'" if(exists($ico{$_}));
		}
	}
}

sub _read{
	open(my $F,$_[0])||return;
	my $s;
	if(my $l=$_[1]||-s $F){
		read($F,$s,$l);
	}else{
		while(<$F>){$s.=$_};
	}
	close($F);
	$s;
}

sub _write{
	open(my $F,$_[0])||return;
	print($F $_[1]) && close($F);
}

sub _restart{
	my $pid=fork();
	$pid && return $pid;
	close(STDOUT);
	open STDOUT,">&2";
	system('killall','-w',$_[0],'-u',$ENV{'USER'});
	exec(@_);
	die $!;
}

# CRC32 code derived from work by Gary S. Brown.
sub crc32{
my $c=$_[1] ^ 0xffffffff;
$c=$crc[($c ^ ord(substr($_[0],$_,1))) & 0xFF] ^ ($c >> 8) for(0..length($_[0])-1);
$c ^ 0xffffffff;
}

# cache-style hashed group naming
sub newname{
	my ($name,$key)=@_;
#	utf8::encode($key);
	$_[0]=~s/\+/'kEy'.crc32($key)/gse or return 1;
	return 0 if(-e $_[0]);
	$name=~s/\.[a-z0-9]*$//i;
	$name=~s/\+/kEy*/gs;
	my @l=glob($name);
	die "Deleting '$name': $!\n" if(@l && !unlink(@l));
	1;
}

sub _tag{
	my $i=$_[2];
	my ($s)=$_[0]=~/<$i>(.*?)<\/$i>/s;
	$i=$_[1].'.'.$i;
	if($#_==2){
		$conf{$i}=$s;
	}else{
		_tag($s,$i,@$_) for(@_[3..$#_]);
	}
}

if(exists($P{slow})){
	$configs{$_}=1 for(glob("${0}_*"));
	if(@{$P{slow}}){
		($fconf,$X,$Y)=@{$P{slow}};
	}else{
		~s/^([A-Z0-9_]*)\([A-Z0-9_]*\) = (.*)?$/$prop{$1}=$2;''/ge  for(split(/\n/,`${bin}obxprop --root`));
		($X,$Y)=$prop{'_NET_DESKTOP_GEOMETRY'}=~/(\d+), (\d+)/;
		($fconf)=$prop{'_OB_CONFIG_FILE'}=~/\"(.*)\"/;
	}
	if(my $s=_read("<$fconf")){
		_tag($s,'',@$_) for(@conf);
		$P{'slow'}=$conf{'.showIcons'} eq 'yes';
		$s=~s/<keybind\s+key=\"(.*?)\".*?>\s*<action name=\"Execute\">.*?<command>(.*?)<\/command>/$key{$2}=$1;''/gse;
		$fconf=~s/[^\/]*$//g;
		$vanilla=$fconf=~/\/openbox$/;
		if($X && $Y){
			for(split(/\s+/,$ENV{YA_APP}),split(/\s*[\r\n]+\s*/,_read('<'.$fconf.'preferred-apps'))){
				my $x=$_;
				push(@apps,($x=~s/.*\///gs)?[$x,$_,$_]:[$_,$x="/usr/bin/$x",$_]);
				$apps{$x}=$apps{$_}=undef;
			}
		}
	};
	icons('/usr/share/icons/');
	while(</usr/share/pixmaps/*.???>){
		chomp($_);
		next if($_=~/\.svg$/);
		$i=$_;
		~s/.*\///;
		$ico{$_}=$i;
		~s/\....$//;
		$ico{$_}=$i;
	}
}

for $f(map{glob $_}('/usr/share/applications/*.desktop','/usr/share/applications/*/*.desktop','/usr/share/ya-layout/Desktop/*.desktop','/usr/share/ya-layout/Desktop/exit/*.desktop','/etc/xdg/autostart/*.desktop','/usr/share/desktop-directories/*.directory')){
	my (%d,%dd,%en,$F,$c);
	if(($i)=$f=~/\/([^\/]*)\.directory$/){
		if($prof){
			$i=~s/^(?:$prof)-//i or next;
		}else{
			$i=~s/^[^-]*-//i;
		}
		$i=join('',map{ucfirst($_)}(split(/-/,$i)));
		open($F,"<$f")||next;
		while(<$F>){
			if(($k,$l,$v)=$_=~/^\s*([^#\s=\[\]#]+)($lang)\s*=([^#\n\r]*)/is){
				$dd{$c}->{$k}->{$l}=$v;
			}elsif(($k)=$_=~/^\s*\[(.*)\]\s*/s){
				$c=$k;
			}
		}
		close($F);
		%d=%{$dd{'Desktop Entry'}};
		$en{$i}=$en{$d{Name}->{''}}=1;
#		print STDERR "$f $i = $cname{$i}\n" if(!exists($cc{$i}) && !exists($cc{$d{Name}->{''}}) && !exists($cc{$cname{$i}}) && !exists($cc{$cname{$d{Name}->{''}}}));
		# same can be in next block (else) too, but fixme:
		# in all known *.desktop "Name=" come before "Name[...]=". So, just can use more CPU.
		# Here we need "Name=" too.
		$_=$_->{(sort keys %$_)[-1]} for(values %d);
	}else{
		open($F,"<$f")||next;
		while(<$F>){
			if(($k,$v)=$_=~/^\s*([^#\s=\[\]#]+)$lang\s*=([^#\n\r]*)/is){
				$dd{$c}->{$k}=$v;
			}elsif(($k)=$_=~/^\s*\[(.*)\]\s*/s){
				$c=$k;
			}
		}
		close($F);
		%d=%{$dd{'Desktop Entry'}};
		exists($d{Exec}) || next;
	}
	next if(exists($d{TryExec}) && !eXist($d{TryExec}));
	$d{Exec}="/usr/bin/ya-session --run +$d{Exec}" if($d{Terminal} && lc($d{Terminal}) ne 'false');
	if(!exists($d{Name})){
		for(Comment,Exec){
			if(exists($d{$_})){
				$d{Name}=$d{$_};
				goto N;
			}
		}
		next;
	}
N:
	if($prof && exists($d{OnlyShowIn}) && !($d{OnlyShowIn}=~/(?:^|;)(?:$prof)(?:;$)/i)){
		$d{Name}="? $d{Name}"
	}
	$i='';
	~s/([$xml_])/\&$xml_{$1};/g for(values %d);
	$icon=undef;
	if(exists($P{slow}) && exists($d{Icon})){
		$i=$d{Icon};
		$i=~s/(?:.*\/)?(.*?).svg$/$1.png/;
		$icon=$i=$ico{$i} if(exists($ico{$i}));
		$i=" icon='$i'";
	}
	if(substr($f,0,4) eq '/etc'){
		$d{Categories}='Autostart';
		if(exists($P{autostart})){
			my $i;
			if(($i=join('|',@{$P{autostart}})||$prof) && !exists($d{OnlyShowIn}) || grep(/^(?:$i)$/i,split(';',$d{OnlyShowIn}))){
				print STDERR "$d{Exec} &\n";
				$d{Name}="+ $d{Name}";
			}
		}
	}
	if($d{Type} eq 'Application'){
		$d{Exec}=~s/\s+%\w$//;
		$d{Name}.=" 	[$key{$d{Exec}}]" if(exists($key{$d{Exec}}));
		$i="<item label='$d{Name}'$i><action name='Execute'><execute>$d{Exec}</execute>".$notify{lc($d{StartupNotify})}.'</action></item>';
		if(exists($apps{$d{Exec}})){
			$apps{$d{Exec}}=[$icon,$d{Exec},$i];
			substr($i,13,0)=' ☑';
		}
	}elsif($d{Type} eq 'Directory'){
		my $d;
		for(keys %en){
			$en{$d}||=0 if($d=$cname{$_});
			$en{$d}||=0 if((($d)=$_=~/^(.*)s$/) && exists($cc{$d}));
		}
		while(my ($n,$c)=each %en){
			if(($d=$d{Name}) ne $n){
				$c+=2000;
			}elsif($i){
				$c+=1000;
			}else{
				next;
			}
			$dir_{$n}=length($d);
			$dir{$n}->{"$d'$i"}++;
			$cc{$n}+=$c;
			$base{$_}||=1;
		}
		next;
	}else{next}
	for(split(/;/,$d{Categories})){
		next if(exists($cat{$i}->{$_}));
		$cat{$i}->{$_}=1;
		$cc{$_}++;
	}
	$cat{$i}=undef if(!exists($cat{$i}));
	if(exists($P{mime}) && exists($d{MimeType})){
		$d{MimeType}=~s/;$//;
		push @{$mime{$_}},$i for(split(/;/,$d{MimeType}));
	}
}
($_)=(sort{$_->{$a}<=>$_->{$b}||-($dir_{$a}<=>$dir_{$b})}keys %$_)[-1] for(values %dir);
$_=defined($_)?[sort{$cc{$a} <=> $cc{$b}}(keys %{$_})]:[$misc] for(values %cat);
push @{$cat1{pop @{$cat{$_}}}},$_ for(keys %cat);
for(keys %cat){
	for $i (@{delete($cat{$_})}){
		push @{$cat1{$i}},$_ if(exists($cat1{$i}) && $base{$i}>0);
	}
}
$dir{$_}||="$_'" for(keys %cc);
$set=$dir{'Settings'};
print '<openbox_pipe_menu><menu id="client-list-combined-menu"/><separator/>';
if(@apps){
	my $ico=$ico{'image-missing'}||$ico{'application-other'}||$ico{'application-x-executable'};
	@apps=map{$apps{$_->[2]}||$apps{$_->[0]}||$apps{$_->[1]}||[$ico{$_->[0]}||$ico,$_->[2]]}@apps;
	if(exists($P{launcher})){
		@crc=map{for(my $i=8;$i>0;$i--){$_=($_&1)?($_>>1)^0xedb88320:($_>>1)};$_}(0..255);
		if(!exists($P{dock}) && !exists($P{tint2}) && (my $pid=$prop{_OPENBOX_PID})){
			if(my $c=_read("/proc/$pid/cmdline")){
				my @c=split(/\x0/,$c);
				for(@c){
					if($_=~s/(?:^|\S*\/)tint2\s+-c\s+//){
						$P{tint2}->[0]=$_;
						last;
					}
				}
			}
		}
		if(exists($P{tint2})){
			$tint2=$P{tint2}->[0]||($vanilla?"$ENV{HOME}/.config/tint2/tint2rc":"$fconf/tint2rc");
			$tint2_=_read("<$tint2");
		}
		my ($a,$m);
		my ($img,$sh,$geo,@wp)=@{$P{launcher}};
		my $wp=join(' ',@wp);
		my ($x,$y,$vert,$xx,$yy,$spliceX,$spliceY,$left,$bottom)=my @geo=split(/\,/,$geo);
		my $n=($xx*$yy)||scalar(@apps);
		my ($sx,$sy)=($x*$xx,$y*$yy);
		$geo=0;
		$geo+=($_ ne '') for(@geo);
		goto NOGEO if($geo>=9);
		$sx||=$X-$spliceX if($spliceX);
		$sy||=$Y-$spliceY if($spliceY);
		if(!$sx && !$sy){
			my ($p,$sz);
			if(exists($P{dock})){
				$p=$conf{'.dock.position'}.$conf{'.dock.direction'};
			}elsif($tint2_){
				($sz)=$tint2_=~/\n\s*panel_size\s*=.*?\%\s+(\d+)/s;
				($p)=$tint2_=~/\n\s*panel_position\s*=\s*([^\n]+)/s;
			}
			if($p){
				$vert=($p=~/vertical/i)||0 if($vert eq '');
				goto nolauncher if(!($bottom=$p=~/bottom/i) && !($p=~/top/i));
				$sz=int($sz/2) if(!($left=$p=~/left/i) && !($p=~/right/i));
				($sx,$sy)=$vert?($sz,0):(0,$sz);
			}
			if(!$sx && !$sy){
				my @splice=$prop{'_NET_WORKAREA'}=~/(\d+), (\d+), (\d+), (\d+)/;
				if($vert ne 1 && ($sy=$splice[1])){
				}elsif($vert ne 0 && ($sx=$splice[0])){
				}elsif($vert ne 1 && ($sy=$Y-$splice[3])){
					$bottom=1;
					$spliceY=$splice[3];
				}elsif($vert ne 0 && ($sx=$X-$splice[2])){
					$left=1;
					$spliceX=$splice[2];
				}else{
					goto nolauncher;
				}
			}
		}
		$vert=$sx && !$sy if($vert eq '');
		$xx||=int($sx/$x) if($x);
		$yy||=int($sy/$y) if($y);
		($n||=$xx*$yy)||goto nolauncher;
		$xx||=$yy?int($n/$yy)+($n%$yy!=0):$vert?1:$n;
		$yy||=$xx?int($n/$xx)+($n%$xx!=0):$vert?$n:1;
		$x||=int($sx/$xx);
		$y||=int($sy/$yy);
		$x||=$y;
		$y||=$x;
		$sx||=$x*$xx;
		$sy||=$y*$yy;
NOGEO:
		$spliceX=($vert xor $left)?$X-$sx:0 if($spliceX eq '');
		$spliceY=($vert xor $bottom)?$Y-$sy:0 if($spliceY eq '');
		my ($a,$c,$p,$xy)=$vert?('[ $1 -lt '.($spliceX+$sx),$y,'$2',$spliceY):('[ $2 -lt '.($spliceY+$sy),$x,'$1',$spliceX);
		$a.=($spliceX?" -a \$1 -gt $spliceX":'').($spliceY?" -a \$2 -gt $spliceY":'')." ] && {\n";
		for(@apps){
			$m.=' '.($_->[0]||next);
			$xy+=$c;
			$a.="	[ $p -lt $xy ] && exec $_->[1]\n";
		}
		$a.=($m?'':"false\n")."}\n";
		$wp='' if(!$wp && ! -r ($wp=(glob("$fconf/wallpaper.*"))[0]));
		# for top-left or composite use feh, else - ImageMagick
		if(!$spliceX && !$spliceY && $yy==1 && ($#wp<1||$wp[1] eq '-a')){
#			$wp||='trans'; # artefacts
			$wp&&=" -b $wp";
			$m="feh -m -W $X -H $Y -y $x -E $y $m$wp -O ";
		}else{
			$m="montage -background none -geometry ${x}x$y -tile ${xx}x$yy $m ";
			$splice=" -splice ${spliceX}x$spliceY";
			if($wp){
				# ppm not transparent, mpc:- keep cache file
				my $f="tiff:-";
				$m.="$f |convert -background none$splice $f -extent ${X}x$Y $f | composite -compose atop $f -resize ${X}x$Y! $wp ";
			}else{
				$m.="ppm:- | convert -background none$splice ppm:- -extent ${X}x$Y "
			}
		}
		if($tint2_){
			my $sz=100-int(100*($vert?$sy/$Y:$sx/$X))-1;
			my ($sz1)=$tint2_=~/\n\s*panel_size\s*=\s*(\S+)\%/s;
			if($sz1 ne $sz){
				$tint2_=~s/(\n\s*panel_size\s*=\s*)\S+\%/$1$sz\%/s;
				_write(">$tint2",$tint2_);
			}
		}
		newname($img,$m.$img.$tint2_)||goto nolauncher;
		unlink($sh);
		$out=`( $m $img ) 2>&1`;
		die "$out" if($?);
		if(!$? && open(my $F,'>',$sh)){
			print $F $a;
			chmod(0700,$F);
			close($F);
			system('/usr/bin/feh','--no-fehbg','--bg-center',$img);
		}
		$tint2_ && _restart('tint2','-c',$tint2);
	}else{
		print map{
			if($#$_==1){
				$_->[1]=~s/([$xml_])/\&$xml_{$1};/g;
				$_->[2]="<item label='$_->[1]'><action name='execute'><execute>$_->[1]</execute></action></item>";
			}
			$_->[2];
		}@apps;
		print '<separator/>';
	}
nolauncher:
}
for(sort{$dir{$a} cmp $dir{$b}}keys %cat1){
	print "<menu id='$id' label='$dir{$_}>",(sort @{$cat1{$_}});
	$id++;
	if(delete($configs{$i="${0}_$_"})){
		print "<separator/><menu id='$id' label='$set execute='$i'/>";
		$id++;
	}
	print '</menu>';
}
for(map{glob $_}(@{$P{include}})){
	if(open(my $F,(-x $_)?"$_|":"<$_")){
		print('<separator />',(<$F>));
		close($F);
	}
}

if(defined($P{mime})){
	for(values %mime){
		for(@$_){
			($_=~s/(<item label='(?: ☑)?).*?(' icon=)/$1\$F$2/g) ||
			($_=~s/(<item label='(?: ☑)?)(.*?)'/$1\$F  [$2]'/g); #'
			$_=~s/(<\/execute)/ \$X$1/g;
		}
	}
	my (%g,%m);
	open($F,'<','/usr/share/mime/globs')||last;
	while(my $s=<$F>){
		chomp($s);
		($i,$t)=split(/:/,$s);
		$g{$t}->{$i}=undef if(exists($mime{$i}));
	}
	close($F);
	print "<separator/>";
	while(($t,$i)=each %g){
		for $i(keys %$i){
			$m{$t}->{$_}=undef for(@{$mime{$i}});
		}
	}
	%g=();
	while(($t,$i)=each %m){
		$g{join('',sort keys %$i)}->{$t}=undef;
	}
	my $fold=ico('folder');
	open($F,'>',$t=shift(@{$P{mime}}))||die $!;
	for my $D(@{$P{mime}}){
#		( -r $D ) &&
		print "<menu id='$id' label='$D' execute='/bin/bash \"$t\" $D'$fold />";
		$id++;
	}
	$i=1;
	if($> && open($FF,'<','/etc/fstab')){
		$i=0;
		while(<$FF>){
			if($_=~/^(?:[^\s#]+\s+){3}(?:\S*,)?users?(?:,\S*)?\s/g){
				$i=1;
				last;
			}
		}
		close($FF);
	}
	print map{"<menu id='".($id++)."' label='$_' execute='${0}mount $_'".ico($_)."/>"}('fs',$i?('mount','umount'):());
	print $F q(#/bin/bash
xml(){
x="${f//&/&amp;}"
x="${x//</&lt;}"
x="${x//>/&gt;}"
x="${x//\'/&apos;}"
x="${x//\"/&quot;}"
}
f="${1%/}"
xml
# avoid automount on ls|stat symlinks
a=false
case "$f" in
/mnt/auto/disk/*/*\);;
/mnt/auto/disk/*\)a=true;f="/dev${f#/mnt/auto}";;
esac
echo "<openbox_pipe_menu><separator label='$x/'/>"
for f in "$f"/*; do
if $a; then
	i=`readlink -f "$f"` && grep -qs "\":$i\"$" /var/run/auto.dev || continue
	f="/mnt/auto${f#/dev}"
fi
xml
X="${x//\\/\\\\}"
X="${X//\$/\\\$}"
X="${X//&quot;/\\&quot;}"
F="${X##*/}"
X="&quot;$X&quot;"
if $a || [ -d "$f" ]; then
$a || [ -e "$f" ] &&
echo "<menu id='fs:$x' label='$F/' execute='/bin/bash &apos;$0&apos; $X'),$fold,q( />"
else
( [ -x "$f" ] && echo "<item label='*$F'><action name='Execute'><execute>/usr/bin/ya-session --run +$X</execute></action></item>" ) ||
[ -r "$f" ] &&
case "${f,,}" in
);
	while(($i,$t)=each %g){
		print $F lc(join('|',keys %$t)),")echo \"$i\";;&\n";
	}
	print $F 'esac
fi
done
echo "</openbox_pipe_menu>"';
	close($F);
}

print '<separator/>';
for(sort keys %configs){
	$i=substr($_,length($0)+1);
	print "<menu id='$id' label='",$dir{$i}||"$i'"," execute='$_'/>";
	$id++
}
print qq(
<menu id=").($id++).qq(" label="OpenBox">
<menu id="client-menu"/>
<menu id="client-list-menu"/>
<item label="Fullscreen"><action name="ToggleFullscreen"/></item>
<item label="Reconfigure"><action name="Reconfigure"/></item>
<item label="Restart"><action name="Restart"/></item>
<separator/>
<menu id=").($id++).qq(" label='$set execute="${0}config"/>
<separator label=""/>
<item label="Exit"><action name="Exit"/></item>
</menu>
</openbox_pipe_menu>
);
