#!/usr/bin/perl
# (c) Denis Kaganovich, Anarchy or GPLv2
# openbox config pipe menu v0.3
# using /usr/share/openbox*/rc.xsd

%xml_=('<'=>'lt','>'=>'gt',"'"=>'apos','"'=>'quot','&'=>'amp');
$xml_=join('',keys %xml_);
$sep=':';

for(@ARGV){
	if($_=~s/^--//){
		undef $P{$i=$_};
	}else{
		push(@{$P{$i}},$_);
	}
}

if($prof=$P{profile}->[0]){
	$cfg="$ENV{HOME}/.config/$prof";
	@rc=("$cfg/rc.xml","/etc/xdg/$prof/rc.xml");
}else{
	if(!($cfg=$P{config}->[0])){
		$i=`obxprop --root`;
		$i=~s/_OB_CONFIG_FILE\(UTF8_STRING\) = \"(\S*)\"/$cfg=$1;''/se;
	}
	@rc=($cfg);
	($cfg=~s/[^\/]*$//) &&
	(($prof)=$cfg=~/.*\/([^\/]+)\/*$/) || die "Detecting openbox config";
}

&fixrc(@{$P{fix}}) if(exists($P{fix}));

my (%type,%xsd,%fontcfg,%fonts,%fonts_);

$fixcmd="$0 --profile $prof --fix";

%nomenu=(
	"ob${sep}openbox_config"=>0,
);

sub load_xml{
	read($_[0],my $s,-s $_[0]) || die $!;
	close($_[0]);
	$s=~s/<!--.*?-->//gs;
	$s=~s/<\?.*?\?>//gs;
	my @tag=({});
	$s=~s/<([\/!]?)([^<>\s\/]*)([^<>]*?)(\/?)>([^<]*)/
	    my $c;
	    my $i=1;
	    if($1 eq '\/'){
		pop @tag;
		$c=$tag[-1];
	    }else{
		push @tag,$c=\%{$tag[-1]->{0}->{$2}->{$3}};
		if($4 || $1){
			$c=pop @tag
		}elsif(exists($c->{1})){
			$i=scalar(keys %$c)+!exists($c->{0})
		}
	    };
#	    $c->{$i}.=$5;
	    if(my ($x)=$5=~\/^\s*(\S.*?)\s*$\/s){ $c->{$i}.=$c->{$i} ne ''?' '.$x:$x; }
	''/ges;
	$tag[0]->{0};
}

sub sort_xsd{
	for my $t(keys %{$_[0]}){
		for my $a(keys %{$_[0]->{$t}}){
			my $id=$_[1];
			my $i=$a;
			my %a;
			$i=~s/([^=\s]+)(?:=\"([^=\s]*)\"|=\'([^=\s]*)\'|)/$a{$1}=$2;''/gse;
			$id.=$sep.$a{'name'} if(exists($a{'name'}));
			$type{$id}=$a{'type'} if(exists($a{'type'}));
			while(my ($x,$y)=each %a){
				push @{$xsd{$t}->{$id}->{$x}},$y;
			}
			sort_xsd($_[0]->{$t}->{$a}->{0},$id);
		}
	}
}

sub sort_tags{
	for my $t(sort keys %{$_[0]}){
		my $id="$_[1]$sep$t";
		my $i1=$t;
		$i1=~s/_/-/g;
		if(exists($nomenu{$id})){
			next if($nomenu{$id});
#			print "<separator label='$i1'/>";
		}else{
			$conf++;
			print "<menu id='config:$conf' label='$i1'>";
		}
		my $A=scalar(keys %{$_[0]->{$t}})>1;
		for my $aa(sort keys %{$_[0]->{$t}}){
			my $a1=$aa;
			$a1=~s/^\s+//s;
			$a1=~s/\s+$//s;
			my $ed="<$t$aa>";
			$ed=~s/([$xml_])/\&$xml_{$1};/g;
			$ed="$_[2] '$ed'";
			my $i;
			$a1=1;
			if($a1&&=$A){
				$i=$aa;
				$i=~s/_/-/g;
				$i=~s/([$xml_])/\&$xml_{$1};/gs;
				$conf++;
				$a1&&=!exists($nomenu{$id});
				print $a1?"<menu id='config:$conf' label='$i'>":"<separator label='$i'/>";
				$i=" $aa";
			}
			for(sort{$a<=>$b}keys %{$_[0]->{$t}->{$aa}}){
			    if(!$_){
				sort_tags($_[0]->{$t}->{$aa}->{0},$id,$ed);
			    }elsif(($d=$_[0]->{$t}->{$aa}->{$_}) ne ''){
				~s/([$xml_])/\&$xml_{$1};/gs for($d);
				my $def="<separator label='$d'/>";
				if(ref($type{$id}) eq ARRAY){
					print map{
						if($_ eq $d){
							my $i=$def;
							$def=undef;
							$i;
						}else{
							"<item label='$_'><action name='Execute'><execute>$fixcmd &quot;$_&quot; $ed &quot;$d&quot;</execute></action></item>"
						}
					}(@{$type{$id}});
				}elsif(ref($type{$id}) eq HASH){
					for(sort keys %{$type{$id}}){
						if($_ eq $d){
							print "<separator label='$type{$id}->{$_}'/>";
							$def=undef;
						}else{
							print "<item label='$type{$id}->{$_}'><action name='Execute'><execute>$fixcmd &quot;$_&quot; $ed &quot;$d&quot;</execute></action></item>"
						}
					};
				}elsif(substr($type{$id},0,1,) eq '<'){
					print $type{$id};
				}
				print $def;
			    }
			}
			$a1 && print '</menu>';
		}
		exists($nomenu{$id}) || print '</menu>';
	}
}

sub fontconfig{
	for(@_){
		next if(defined($fontcfg{$_}));
		$fontcfg{$_}++;
		if(stat($_) && -f && -r _ && -s _){
			my $d=$_;
			$d=~s/[^\/]*$//;
			sort_fonts(load_xml(open_(my $F,'<',$_)),$d)
		}
	}
}

sub walk{
	my $x=$_[1];
	ref($_[0])?defined($x)?ref($x)?map{walk($_[0]->{$_},@_[2..$#_])}(grep(/$x->[0]/,keys %{$_[0]})):walk($_[0]->{$x},@_[2..$#_]):$#_?map{walk($_[0]->{$_},@_[2..$#_])}(keys %{$_[0]}):($_[0]):$#_?():($_[0]);
}

sub sort_fonts{
	for(walk($_[0],'fontconfig',undef,undef,'include',undef,undef)){
		next if(ref($_));
		my $f=$_;
		$f="$_[1]$f" if(substr($f,0,1) ne '/');
		fontconfig($f,"$f.conf",glob('[0-9][0-9]-$f.conf'),glob("$f/[0-9][0-9]-*.conf"))
	}
	for(walk($_[0],'fontconfig',undef,0,'alias',undef,0)){
		next if(ref($_) ne 'HASH');
		my @a=walk($_,undef,undef,0,undef,undef,undef);
		for my $x (walk($_,'family',undef,undef)){
			next if(ref($x) || exists($fonts{$x}));
			for my $y (@a){
				$fonts_{$x}->{$y}='*' if(!ref($y));
			}
		}
	}
	for(walk($_[0],'fontconfig',undef,0,'match',['\starget=["\']pattern["\']'],0)){
		next if(ref($_) ne 'HASH');
		my @a=walk($_,'edit',['\sname=["\']family["\']'],0,'string',undef,undef);
		for my $x (walk($_,'test',['\sname=["\']family["\']'],0,'string',undef,undef)){
			next if(ref($x) || exists($fonts{$x}));
			for my $y (@a){
				$fonts_{$x}->{$y}='~' if(!ref($y));
			}
		}
	}
}

sub open_{
	open($_[0],@_[1,$_]) && return $_[0] for(2..$#_);
	die "Error open '".join('|',@_[2..$#_])."'\n";
}

sub fixrc(){
$qm=1;
open_(my $F,'<',@rc);
mkdir($cfg)||die $! if(! -d $cfg);
read($F,$s,-s $F)||die $!;
print "$rc[0]";;
close($F);
my ($from,$to);
$to=shift;
if(substr($_[-1],0,2) ne '</'){
	$from=pop(@_);
}
my $rc1=$rc[0].'.$$$';
my ($p1,$p2);
for(@_){
	my $x=$_;
	if(substr($x,0,2) ne '</'){
		$x=~s/\s.*/>/s;
		substr($x,1,0)='/';
		$p2='.*?'.($qm?quotemeta($x):$x).$p2;
		$p1.=($qm?quotemeta($_):$_).'.*?';
	}else{
		$p2=($qm?quotemeta($x):$x).$p2;
	}
}
($s=~s/($p1)$from($p2)/$1$to$2/gs) || die "Not found\n";
open($F,'>',$rc1) && print($F $s) && close($F) && rename($rc1,$rc[0]) || die $!;
exec('/usr/bin/openbox','--reconfigure');
exit;
}

~s/^.*:\s(.*?):.*$/$fonts{$1}=$1/e for(split(/\n/,`/usr/bin/fc-list`));
if(!$?){
	fontconfig('/etc/fonts/fonts.conf');
	for(my ($n,$n1)=(1); $n ne $n1; ($n,$n1)=(scalar(%fonts),$n)){
		for(keys %fonts_){
			for my $i (keys %{$fonts_{$_}}){
				if(exists($fonts{$i})){
					my $x=$fonts{$i};
					$x=~s/[^\*\~]*//;
					$fonts{$_}="$_ ".delete($fonts_{$_})->{$i}.$x;
					last
				}
			}
		}
	}
}
%fonts_=();

sort_xsd(load_xml(open_($F,'<',reverse glob('/usr/share/doc/openbox*/rc.xsd'))),'ob');
for (values %type){
	# don't know what to do else now. todo
	$_=exists($xsd{'xsd:enumeration'}->{$_})?$xsd{'xsd:enumeration'}->{$_}->{'value'}:undef;
}
for(0..2){
for(keys %type){
	if(exists($xsd{'xsd:element'}->{$_})){
		for my $i (@{$xsd{'xsd:element'}->{$_}->{'type'}}){
			for my $ii (grep(/^$i$sep.*/,keys %type)){
				my $t=$ii;
				$t=~s/^$i//;
				$type{$_.$t}=$type{$ii};
			}
		}
	}
}
}
%xsd=();
$type{join($sep,'ob','openbox_config','theme','name')}=[(map{substr($_,18,-10)}glob('/usr/share/themes/*/openbox-3')),'/dev/null'];
$type{join($sep,'ob','openbox_config','theme','font','size')}=[(5..32)];
$type{join($sep,'ob','openbox_config','theme','font','name')}=\%fonts;

print '<openbox_pipe_menu>';
sort_tags(load_xml(open_($F,'<',@rc)),'ob');
print '</openbox_pipe_menu>';
