#!/usr/bin/perl
# (c) Denis Kaganovich, Anarchy or GPLv2
# openbox config pipe menu v0.7
# using /usr/share/openbox*/rc.xsd

%xml_=('<'=>'lt','>'=>'gt',"'"=>'apos','"'=>'quot','&'=>'amp');
$xml_=join('',keys %xml_);
$sep=':';
$MENU='config';
$show_empty=0;
#$sel='+';

$SIG{__DIE__}=sub{
return if(!exists($ENV{DBUS_SESSION_BUS_ADDRESS}));
print STDERR ($e=join('',"$0: ",@_));
exec('/usr/bin/notify-send','-t',6000,$e);
};

sub utf8_encode{};
sub utf8_decode{};
if(1){ # perl version?
	*utf8_encode=*utf8::encode;
	*utf8_decode=*utf8::decode;
#	$filemode=':utf8';
}

for(@ARGV){
	if($_=~s/^--//){
		undef $P{$i=$_};
	}else{
		push(@{$P{$i}},$_);
	}
}

if(exists($P{''}) && substr(scalar(%P),0,2) eq '1/'){
#	$P{profile}='ya';
	$P{fix}=$P{''};
}

if($prof=$P{profile}->[0]){
	$cfg="$ENV{HOME}/.config/$prof";
	@rc=("$cfg/rc.xml","/etc/xdg/$prof/rc.xml");
}else{
	if(!($cfg=$P{config}->[0])){
		~s/^([A-Z0-9_]*)\([A-Z0-9_]*\) = (.*)?$/$prop{$1}=$2;''/ge for(split(/\n/,`/usr/bin/obxprop --root`));
		$cfg=$prop{'_OB_CONFIG_FILE'};
		$cfg=~s/\"//gs;
	}
	@rc=($cfg);
	($cfg=~s/[^\/]*$//) &&
	(($prof)=$cfg=~/.*\/([^\/]+)\/*$/) || die "Detecting openbox config";
}

my (%type,%xsd,%fontcfg,%fonts,%fonts_,%CNT,%xtype);

$cmd="$0 --profile $prof";
$fix=$0;
#~s/^\/usr\/bin\///gs for($cmd,$fix);

$ID="ob${sep}openbox_config";

%call_tags=(
	'font'=>0,
#	'ob:action'=>0,
#	'ob:actionname'=>0,
	'action'=>0,
);

%subinit=(
join($sep,'ob','openbox_config','theme','font')=>\&fonts,
);

%xtype=(
'ob:keyname'=>"<menu id='' label='' execute='--menu ob:keyname &quot;&quot;'/>",
'ob:button'=>"<menu id='' label='' execute='--menu ob:button &quot;&quot;'/>",
);

%menu=(
'ob:keyname'=>\&keymap,
'ob:button'=>\&button,
);

%cmd=(
'fix'=>\&fixrc,
# todo
'app'=>sub{
#	open_(my $F,'<',"$ENV{HOME}/.cache/$prof/menu.xml");
#	read($F,my $s,-s $F);
	open_(my $F,'|-',"/usr/bin/ob3menu-cache /usr/bin/ob3menu --slow $ENV{HOME}/.config/ya/rc.xml");
	$s=join('',<$F>);
	close($F);
	utf8_decode($s);
	$s=~s/(<menu id=[\'\"])/$1$$:/gs;
	~s/([$xml_])/\&$xml_{$1};/g for(@_);
	my $p=join("' '",@_);
	$s=~s/(<action.*?<\/action>)/
		my $i=$1;
		$i=~s\/([$xml_])\/\&$xml_{$1};\/g;
		"<action name='execute'><execute>$fix '$i' '$p'<\/execute><\/action>"
	/gse;
	print $s;
	exit;
},
'id'=>sub{
	$ID=$_[0];
	&{$subinit{$ID}}(@_) if(exists($subinit{$ID}));
	$MENU=join($sep,$MENU,@_);
},
# current submenu design looks not best, but simple, fast & recursive
'menu'=>sub{
	my $m=shift;
	for(@_){
		~s/([$xml_])/\&$xml_{$1};/gs;
		$_="&apos;$_&apos;"
	}
	$MENU.=":$m:$_[1]:$$";
	print '<openbox_pipe_menu>';
	&{$menu{$m}}(@_);
	print '</openbox_pipe_menu>';
	exit;
},
);

sub load_xml{
	read($_[0],my $s,-s $_[0]) || die $!;
	close($_[0]);
	utf8_decode($s);
	### bugfix
	if($_[1]){
		$s=~s/name=\"monitor\" type=\"ob:primarymonitor\"/name=\"primaryMonitor\" type=\"ob:primarymonitor\"/;
		$s=~s/:enumeration value=\"\[0-/:pattern value=\"[0-/;
	}
	### /bugfix
	$s=~s/<!--.*?-->//gs;
	$s=~s/<\?.*?\?>//gs;
	my @tag=({});
	$s=~s/<([\/!]?)([^<>\s\/]*)([^<>]*?)(\/?)>([^<]*)/
	    my $c;
	    my $i=1;
	    if($1 eq '\/'){
		pop @tag;
		$c=$tag[-1];
	    }else{
		push @tag,$c=\%{$tag[-1]->{0}->{$2}->{$3}};
		if($4 || $1){
			$c=pop @tag
		}elsif(exists($c->{1})){
			$i=2;
		}
	    }
	    if(my ($x)=$5=~\/^\s*(\S.*?)\s*$\/s){
		$i+=scalar(keys %$c)-exists($c->{0});
		$c->{$i}.=$c->{$i} ne ''?' '.$x:$x;
	    }
	''/ges;
	$tag[0]->{0};
}

sub sort_xsd{
	for my $t(keys %{$_[0]}){
		for my $a(keys %{$_[0]->{$t}}){
			my $id=$_[1];
			my $i=$a;
			my %a;
			$i=~s/([^=\s]+)(?:=\"([^=\"]*)\"|=\'([^=\']*)\'|)/$a{$1}=$2;''/gse;
			$id.=$sep.$a{'name'} if(exists($a{'name'}));
			$type{$id}=$a{'type'} if(exists($a{'type'}));
			while(my ($x,$y)=each %a){
				push @{$xsd{$t}->{$id}->{$x}},$y;
			}
			sort_xsd($_[0]->{$t}->{$a}->{0},$id);
		}
	}
}

sub type{
	for(my ($i,$x)=($_[0],1); $x; $x=($i=~s/^([^:]*):[^:]*/$1/)){
		if(exists($type{$i})){
			return $type{$_[0]}=$type{$i};
		}
	}
}

sub _call{
for(@{$_[1]},$_[0]){
#	next if(!exists($call_tags{$_}) && ref($_) ne SCALAR_);
	next if(!exists($call_tags{$_}));
	my $i=$_[0];
	$i=~s/([$xml_])/\&$xml_{$1};/gs;
	$_[2]=~s/\'>$/:\' execute='$0 --id $i $CNT{$_[0]}'\/>/s;
	utf8_encode($_[2]);
	return print $_[2];
}
}

sub cmpid{
	if(($_[1]=$_[0] cmp $ID)<0){
		$_[2]=1;
		return index($ID.$sep,$_[0].$sep);
	}elsif($_[1]>0){
		return index($_[0].$sep,$ID.$sep);
	}
	exists($P{id}) && $P{id}->[1] ne $CNT{$_[0]}
}

sub sort_tags{
	for my $t(sort keys %{$_[0]}){
		my $id="$_[1]$sep$t";
		$CNT{$id}++;
		cmpid($id,my $cmpid,my $silent) && next;
		my $submenu;
		my $A=scalar(keys %{$_[0]->{$t}});
		my $type=type($id);
		my $menu1;
		if($cmpid){
			my $i=$t;
			$i=~s/_/-/g;
			$i.=(keys %{$_[0]->{$t}})[0] if($A==1);
			$conf++;
			$submenu="<menu id='$MENU:$conf' label='$i'>";
			next if(!$silent && _call($id,[$t,$type],$submenu));
		}elsif(!exists($P{id})){
			$silent=1;
		}
		for my $aa(sort keys %{$_[0]->{$t}}){
			my $ed=$_[2];
			my ($i,$menu2,%a);
			if($t ne ''){
				$i=$t.(($A==1 && $aa && !scalar(%a))?substr($aa,0,1):$aa.'>');
#				$i="$t$aa>";
				$i=~s/([$xml_])/\&$xml_{$1};/gs;
				$ed.=' &apos;&lt;'.$i.'&apos;';
			}
			$i=$aa;
			$i=~s/([^=\s]+)(?:=\"([^=\"]*)\"|=\'([^=\']*)\'|)/my $x=type("$id$sep$1");$a{$1}=$2 if(ref($x) ne 'HASH' || scalar(%$x));''/gse;
			my $branch=delete($_[0]->{$t}->{$aa});
			if(!$silent && (($i=($aa=~/\S/s)) || $A>1 || scalar(%$branch) || $show_empty)){
			    $menu1||=$submenu;
			    if($A>1 && $i){
				$i=$aa;
				$i=~s/_/-/gs;
				$i=~s/([$xml_])/\&$xml_{$1};/gs;
				$conf++;
				$submenu.="<menu id='$MENU:$conf' label='$i'>";
				$menu2=1;
			    }
			    utf8_encode($submenu);
			    print $submenu;
			}
			$submenu=undef;
			my $r=ref($type);
			for(sort{$a<=>$b}keys %$branch,undef,sort keys %a){
			    my ($d,$menu3);
			    my ($id,$r,$ed,$type)=($id,$r,$ed,$type);
			    if(exists($branch->{$_})){
				$d=delete($branch->{$_});
				if(!$_){
					sort_tags($d,$id,$ed);
					next;
				}
				$ed.="[$_]" if($_>1);
			    }elsif(exists($a{$_})){
				$d=delete($a{$_});
				$id.=$sep.$_;
				$CNT{$id}++;
				cmpid($id,my $cmpid,my $silent=$silent) && next;
				$type=type($id);
				$type || next;
				$r=ref($type);
				$i=$_;
				$i=~s/([$xml_])/\&$xml_{$1};/gs;
				$ed.=" $i=";
				$conf++;
				$i="<menu id='$MENU:$conf' label='$i='>";
				next if($cmpid && ($silent || _call($id,[$type],$i)));
				if(!$silent){
					$menu3=1;
					utf8_encode($i);
					print $i;
				}
			    }elsif($silent){
				next;
			    }else{
				scalar(%a) && print '<separator/>';
				next;
			    }
			    if($d ne ''){
				~s/([$xml_])/\&$xml_{$1};/gs for($d);
				my $def="<separator label='$sel$d'/>";
				if($r eq ARRAY){
					for(@{$type}){
						if($_ eq $d){
							($i,$def)=($def);
						}else{
							$i="<item label='$_'><action name='Execute'><execute>$fix &quot;$_&quot; $ed &quot;$d&quot;</execute></action></item>"
						}
						utf8_encode($i);
						print $i;
					}
				}elsif($r eq HASH){
					for(sort keys %{$type}){
						my $x=$i=$type->{$_};
						($i,$x)=@{$i} if(ref($i));
						if($d=~/^$_$/){
							($i,$def)=("<separator label='$sel$x'/>");
						}else{
							$i="<item label='$x'><action name='Execute'><execute>$fix &quot;$i&quot; $ed &quot;$d&quot;</execute></action></item>"
						}
						utf8_encode($i);
						print $i;
					};
				}elsif($r eq SCALAR){
					$i=$xtype{$$type};
					$i=$xtype{$$type}=&{$i}() if(ref($i) eq CODE);
					$i=~s/(<menu id=[\'\"])/$conf++;"$1$MENU:$conf"/gse;
					$i=~s/(<execute>)([^<>]*)(<\/execute>)/$1$fix $2 $ed &quot;$d&quot;$3/gs;
					$i=~s/ label=\'\'/ label=\'[$$type]\'/gs;
					my $ed=$ed;
					$ed=~s/(\s)/'&#'.ord($1).';'/gse;
					$i=~s/( execute=\')([^\']*)(\')/$1$fix $2 $ed &quot;$d&quot;$3/gs;
					$def.=$i;
					undef $i;
#				}elsif(substr($type,0,1) eq '<'){
#					$def=$type;
				}
				if(defined($def)){
					utf8_encode($def);
					print $def;
				}
			    }
			    $menu3 && print '</menu>';
			}
			$menu2 && print '</menu>';
		}
		$menu1 && print '</menu>';
	}
}

sub fontconfig{
	for(@_){
		next if(defined($fontcfg{$_}));
		$fontcfg{$_}++;
		if(stat($_) && -f && -r _ && -s _){
			my $d=$_;
			$d=~s/[^\/]*$//;
			sort_fonts(load_xml(open_(my $F,'<',$_)),$d)
		}
	}
}

sub walk{
	my $x=$_[1];
	ref($_[0])?defined($x)?ref($x)?map{walk($_[0]->{$_},@_[2..$#_])}(grep(/$x->[0]/,keys %{$_[0]})):walk($_[0]->{$x},@_[2..$#_]):$#_?map{walk($_[0]->{$_},@_[2..$#_])}(keys %{$_[0]}):($_[0]):$#_?():($_[0]);
}

sub sort_fonts{
	for(walk($_[0],'fontconfig',undef,undef,'include',undef,undef)){
		next if(ref($_));
		my $f=$_;
		$f="$_[1]$f" if(substr($f,0,1) ne '/');
		fontconfig($f,"$f.conf",glob('[0-9][0-9]-$f.conf'),glob("$f/[0-9][0-9]-*.conf"))
	}
	for(walk($_[0],'fontconfig',undef,0,'alias',undef,0)){
		next if(ref($_) ne 'HASH');
		my @a=walk($_,undef,undef,0,undef,undef,undef);
		for my $x (walk($_,'family',undef,undef)){
			next if(ref($x) || exists($fonts{quotemeta($x)}));
			for my $y (@a){
				$fonts_{$x}->{quotemeta($y)}='*' if(!ref($y));
			}
		}
	}
	for(walk($_[0],'fontconfig',undef,0,'match',['\starget=["\']pattern["\']'],0)){
		next if(ref($_) ne 'HASH');
		my @a=walk($_,'edit',['\sname=["\']family["\']'],0,'string',undef,undef);
		for my $x (walk($_,'test',['\sname=["\']family["\']'],0,'string',undef,undef)){
			next if(ref($x) || exists($fonts{quotemeta($x)}));
			for my $y (@a){
				$fonts_{$x}->{quotemeta($y)}='~' if(!ref($y));
			}
		}
	}
}

sub open_{
	open($_[0],$_[1]?$_[1].$filemode:$_[1],$_[$_]) && return $_[0] for(2..$#_);
	die "Error open '".join('|',@_[2..$#_])."'\n";
}

sub fixrc(){
open_(my $F,'<',@rc);
mkdir($cfg)||die $! if(! -d $cfg);
read($F,$s,-s $F)||die $!;
utf8_decode($s);
print "$rc[0]";
close($F);
my ($from,$to);
$to=shift;
if(substr($_[-1],0,2) ne '</'){
	$from=quotemeta(pop(@_));
}
my $rc1=$rc[0].'.$$$';
my ($p1,$p2);
if(substr($_[-1],-1) eq '='){
	my $a=pop @_;
	my $t=pop @_;
	$t=~s/>$//;
	my $t1=$t;
	$t1=~s/(\s)$a([\'\"])$from[\'\"]/$1$a$2$to$2/s or die "Not found";
	$from=quotemeta($t);
	$to=$t1;
}
for(@_){
	my $n=1;
	$_=~s/\[(\d+)\]$/$n=$1;''/se;
	my $x=$_;
	if(substr($x,0,2) eq '</'){
		$p2=quotemeta($x).'.*?'.$p2;
	}else{
		$x=~s/\s.*/>/s;
		substr($x,1,0)='/';
		$p2=quotemeta($x).'.*?'.$p2 for(1..$n);
		$p1.='.*?'.quotemeta($_);
	}
}
my $sl='/';
($s=~s/($p1)(.*?)($p2)/
	my @x=($1,$2,$3);
	$x[1]=~s\/$from\/$to\/s or  die "Not found";
	join('',@x)
/se) || die "Not found";
utf8_encode($s);
open_($F,'>',$rc1) && print($F $s) && close($F) && rename($rc1,$rc[0]) || die $!;
exec('/usr/bin/openbox','--reconfigure');
exit;
}

sub fonts{
~s/^(?:.*:\s)?(.+):.*$/$fonts{quotemeta($1)}=[$1,$1]/e for(split(/\n/,`/usr/bin/fc-list`));
if(!$?){
	fontconfig('/etc/fonts/fonts.conf');
	for(my ($n,$n1)=(1); $n ne $n1; ($n,$n1)=(scalar(%fonts),$n)){
		for(keys %fonts_){
			for my $i (keys %{$fonts_{$_}}){
				if(exists($fonts{$i})){
					my $x=$fonts{$i}->[1];
					$x=~s/[^\*\~]*//;
					$fonts{quotemeta($_)}=[$_,"$_ ".delete($fonts_{$_})->{$i}.$x];
					last
				}
			}
		}
	}
}
%fonts_=();
}

sub _menu{
	join('',map{
		my $k=$_;
		my $x=delete($_[0]->{$k});
		my $i;
		while(($i=ref($x)?scalar(keys %$x):0)==1 && defined($_[1])){
			my $n=(keys %$x)[0];
			$x=$x->{$n};
			$k.=$_[1].$n;
		}
		$k=~s/([$xml_])/\&$xml_{$1};/gs;
		$k1=$k;
		$k1=~s/_/ /g;
		$i?"<menu id='$MENU".(++$conf)."' label='$k1'>"._menu($x,@_[1..$#_]).'</menu>':
		"<item label='$k1'><action name='execute'><execute>$0 $_[2]&quot;$k&quot; $_[3]</execute></action></item>"
	}sort{lc($a) cmp lc($b)||$a cmp $b}keys %{$_[0]});
}

sub keymap{
	my (%k,%kk);
	my $ed=join(' ',@_[1..$#_]);
	open(my $F,'-|','/usr/bin/xmodmap -pke');
	while(<$F>){
		~s/^keycode\s+(\d+)\s+=\s+(.+?)\s*$/$k{$_}=$1 for(split(\/\s+\/,$2));''/ge;
	}
	close($F);
	for('A','C','M','S','W'){
		next if($_[0]=~/$_-/);
		$conf++;
		print "<menu id='$MENU:$conf' label='$_-' execute='$0 --menu ob:keyname $_[0]$_- $ed'/>";
	}
	print '<separator/>';
	for my $p('[0-9]','[a-z]','[A-Z]','F[0-9]+'){
		$conf++;
		print "<menu id='$MENU:$conf' label='$p'>";
		for(sort{length($a)<=>length($b)||lc($a) cmp lc($b)||$a cmp $b}grep(/^$p$/,keys %k)){
			delete($k{$_});
			~s/([$xml_])/\&$xml_{$1};/gs;
			print "<item label='$_'><action name='execute'><execute>$0 $_[0]&quot;$_&quot; $ed</execute></action></item>\n"
		}
		print '</menu>';
	}
	for(keys %k){
		my $x=\%kk;
		$x=\%{$x->{$_}} for(split(/_/,$_));
	}
	print '<separator/>',_menu(\%kk,'_',$_[0],$ed)
}

sub button{
	my (%k,%kk);
	my $ed=join(' ',@_[1..$#_]);
	for('A','C','M','S','W'){
		next if($_[0]=~/$_-/);
		$conf++;
		print "<menu id='$MENU:$conf' label='$_-' execute='$0 --menu ob:button $_[0]$_- $ed'/>";
	}
	print '<separator/>';
	for('Left','Middle','Right','Up','Down',map{"Button$_"}(0..12)){
			print "<item label='$_'><action name='execute'><execute>$0 $_[0]&quot;$_&quot; $ed</execute></action></item>\n"
	}
}

sub xsd{
sort_xsd(@_);
for my $t (keys %xsd){
	for (keys %{$xsd{$t}}){
		$type{$_}=$_ if(!exists($type{$_}));
	}
}
for(keys %{$xsd{'xsd:union'}}){
	for my $i (map{split(/\s+/,$_)}(@{$xsd{'xsd:union'}->{$_}->{'memberTypes'}})){
		for my $t(keys %xsd){
			push @{$xsd{$t}->{$_}->{'value'}}, @{$xsd{$t}->{$i}->{'value'}} if(exists($xsd{$t}->{$i}));
		}
	}
}
$_->{'value'}=[sort @{$_->{'value'}}] for(values %{$xsd{'xsd:enumeration'}});
$xsd{'xsd:enumeration'}->{'ob:bool'}->{'value'}={'(?:yes|true|on)'=>'on','(?:no|false|off)'=>'off'};
for my $t(values %type){
    for(ref($t)?@$t:$t){
	if(exists($xtype{$_})){
		my $i=$_;
		$t=\$i;
	}elsif(exists($xsd{'xsd:pattern'}->{$_})){
		my %e;
		if(ref($xsd{'xsd:enumeration'}->{$_}->{'value'}) eq 'ARRAY'){
			$e{quotemeta($_)}=$_ for(@{$xsd{'xsd:enumeration'}->{$_}->{'value'}});
		}
		for(@{delete($xsd{'xsd:pattern'}->{$_})->{'value'}}){
			$i=$_;
			$i=~s/\[([a-z])([a-z])\]/$1/gsi;
			if($i=~/[\[\]\{\}\*\.\|\+]/){
#				$enum=(); last;
				next;
			}
			$e{$_}=$i;
		}
		$xsd{'xsd:enumeration'}->{$_}->{'value'}=\%e;
	}
	$_=$xsd{'xsd:enumeration'}->{$_}->{'value'}||$_;
    }
}
%xsd=();
}

###########################################
for(keys %P){
	&{$cmd{$_}}(@{$P{$_}}) if(exists($cmd{$_}));
}

xsd(load_xml(open_($F,'<',reverse glob('/usr/share/doc/openbox*/rc.xsd')),1),'ob');

$type{join($sep,'ob','openbox_config','theme','name')}=[(map{substr($_,18,-10)}glob('/usr/share/themes/*/openbox-3')),'/dev/null'];
$type{join($sep,'ob','openbox_config','desktops','firstdesk')}=[$prop{'_NET_CURRENT_DESKTOP'}+1];
$type{join($sep,'ob','openbox_config','desktops','number')}=[$prop{'_NET_NUMBER_OF_DESKTOPS'}||()];
$type{join($sep,'ob','openbox_config','theme','font','name')}=\%fonts;
$type{join($sep,'ob','openbox_config','theme','font','size')}=[(5..32)];

print '<openbox_pipe_menu>';
sort_tags(load_xml(open_($F,'<',@rc)),'ob');
print '</openbox_pipe_menu>';
