--- a/server/mpm/experimental/itk/itk.c	2011-12-14 14:35:11.000000000 +0300
+++ b/server/mpm/experimental/itk/itk.c	2011-12-14 17:01:53.000000000 +0300
@@ -107,6 +107,8 @@
 #define HARD_THREAD_LIMIT 1
 #endif
 
+#define ITK_USE_CLONE defined(CLONE_VFORK)
+
 /* config globals */
 
 int ap_threads_per_child=0;         /* Worker threads per child */
@@ -120,6 +122,9 @@ static int first_server_limit = 0;
 static int changed_limit_at_restart;
 static int mpm_state = AP_MPMQ_STARTING;
 static ap_pod_t *pod;
+#if ITK_USE_CLONE
+static int clone_flags = 0;
+#endif
 
 /*
  * The max child slot ever assigned, preserved across restarts.  Necessary
@@ -502,17 +507,34 @@ int ap_graceful_stop_signalled(void)
     return mpm_state == AP_MPMQ_STOPPING;
 }
 
+conn_rec *current_conn;
+void *csd;
+apr_pool_t *ptrans;
+ap_sb_handle_t *sbh;
+apr_bucket_alloc_t *bucket_alloc;
+
+#if ITK_USE_CLONE
+static int do_child(void *arg)
+#else
+static inline void do_child()
+#endif
+{
+    apr_proc_mutex_child_init(&accept_mutex, ap_lock_fname, pchild);
+    current_conn = ap_run_create_connection(ptrans, ap_server_conf, csd, my_child_num, sbh, bucket_alloc);
+    if (current_conn) {
+        ap_process_connection(current_conn, csd);
+        ap_lingering_close(current_conn);
+    }
+    exit(0);
+}
 
 static void child_main(int child_num_arg)
 {
-    apr_pool_t *ptrans;
     apr_allocator_t *allocator;
     apr_status_t status;
     int i;
     ap_listen_rec *lr;
     apr_pollset_t *pollset;
-    ap_sb_handle_t *sbh;
-    apr_bucket_alloc_t *bucket_alloc;
     int last_poll_idx = 0;
 
 #if HAVE_LIBCAP
@@ -606,8 +628,6 @@ static void child_main(int child_num_arg
      * shutdown_pending is set when SIGTERM is received when running
      * in single process mode.  */
     while (!die_now && !shutdown_pending) {
-        conn_rec *current_conn;
-        void *csd;
 
         /*
          * (Re)initialize this child to a pre-connection state.
@@ -720,20 +740,21 @@ static void child_main(int child_num_arg
          */
 
         {
+#if ITK_USE_CLONE
+            long stack_size = sysconf(_SC_PAGESIZE);
+            pid_t pid = clone(do_child, alloca(stack_size) + stack_size, clone_flags, NULL), child_pid;
+#else
             pid_t pid = fork(), child_pid;
+#endif
             int status;
             switch (pid) {
             case -1:
                 ap_log_error(APLOG_MARK, APLOG_ERR, errno, NULL, "fork: Unable to fork new process");
                 break;
+#if !ITK_USE_CLONE
             case 0: /* child */
-                apr_proc_mutex_child_init(&accept_mutex, ap_lock_fname, pchild);
-                current_conn = ap_run_create_connection(ptrans, ap_server_conf, csd, my_child_num, sbh, bucket_alloc);
-                if (current_conn) {
-                    ap_process_connection(current_conn, csd);
-                    ap_lingering_close(current_conn);
-                }
-                exit(0);
+                do_child();
+#endif
             default: /* parent; just wait for child to be done */
                 do {
                     child_pid = waitpid(pid, &status, 0);
@@ -1433,6 +1454,9 @@ static int itk_pre_config(apr_pool_t *p,
 #ifdef AP_MPM_WANT_SET_MAX_MEM_FREE
     ap_max_mem_free = APR_ALLOCATOR_MAX_FREE_UNLIMITED;
 #endif
+#if ITK_USE_CLONE
+    clone_flags = SIGCHLD | CLONE_VFORK;
+#endif
 
     apr_cpystrn(ap_coredump_dir, ap_server_root, sizeof(ap_coredump_dir));
 
@@ -1697,6 +1719,19 @@ static const char *set_nice_value (cmd_p
     return NULL;
 }
 
+static const char *set_clone_flags(cmd_parms *cmd, void *dummy, const char *arg)
+{
+#if ITK_USE_CLONE
+    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
+    if (err != NULL) {
+        return err;
+    }
+
+    clone_flags = (SIGCHLD | CLONE_VFORK) ^ atoi(arg);
+#endif
+    return NULL;
+}
+
 static const command_rec itk_cmds[] = {
 UNIX_DAEMON_COMMANDS,
 LISTEN_COMMANDS,
@@ -1716,6 +1751,8 @@ AP_INIT_TAKE1("MaxClientsVHost", set_max
               "Maximum number of children alive at the same time for this virtual host."),
 AP_INIT_TAKE1("NiceValue", set_nice_value, NULL, RSRC_CONF|ACCESS_CONF,
               "Set nice value for the given vhost, from -20 (highest priority) to 19 (lowest priority)."),
+AP_INIT_TAKE1("CloneFlags", set_clone_flags, NULL, RSRC_CONF,
+              "XOR to default (SIGCHLD|CLONE_VFORK) clone() flags. CLONE_VM=0x100, CLONE_FS=0x200."),
 AP_GRACEFUL_SHUTDOWN_TIMEOUT_COMMAND,
 { NULL }
 };
