#!/sbin/runscript
# Copyright 1999-2007 Gentoo Foundation
# Distributed under the terms of the GNU General Public License, v2 or later
# $Header: /var/cvsroot/gentoo-x86/sys-cluster/drbd/files/drbd-8.0.rc,v 1.5 2007/11/12 00:18:35 xmerlin Exp $

opts="${opts} reload"

DEFAULTFILE="/etc/conf.d/drbd"
DRBDADM="/sbin/drbdadm"
PROC_DRBD="/proc/drbd"
MODPROBE="/sbin/modprobe"
RMMOD="/sbin/rmmod"
UDEV_TIMEOUT=10
ADD_MOD_PARAM=""
DRBD_WAIT_SYNC="wait-sync --wait-after-sb --outdated-wfc-timeout=5 --degr-wfc-timeout=5 --wfc-timeout=5"
DRBD_WAIT_PRIMARY="wait-sync --wait-after-sb --outdated-wfc-timeout=0 --degr-wfc-timeout=0 --wfc-timeout=0"
DRBD_CLIENTS="heartbeat ocfs2"
DRBD_EMERGE_MODULE="upgrade"
DRBD_HIDE_WAIT="no"
DRBD_RMMOD="no"

if [ -f $DEFAULTFILE ]; then
  . $DEFAULTFILE
fi

depend() {
	use logger
	need net
	before $DRBD_CLIENTS
	after sshd
}

# Just in case drbdadm want to display any errors in the configuration
# file, or we need to ask the user about registering this installation
# at http://usage.drbd.org, we call drbdadm here without any IO
# redirection.
$DRBDADM sh-nop

function assure_module_is_loaded() {
	[ -e "$PROC_DRBD" ] && return
	ebegin "Loading drbd module"
	ret=0

	if [[ "$1" == 1 ]]; then
		insmod /lib/modules/`uname -r`/block/drbd/drbd.ko `$DRBDADM sh-mod-parms` $ADD_MOD_PARAM || ret 20
	else
	$MODPROBE -s drbd `$DRBDADM sh-mod-parms` $ADD_MOD_PARAM || 
	    insmod /lib/modules/`uname -r`/kernel/drivers/block/drbd/drbd.ko `$DRBDADM sh-mod-parms` $ADD_MOD_PARAM ||
	    ret=20
	fi
	eend $ret
	return $ret
}

function adjust_with_progress() {
	CMD="adjust"
	[[ -e "$PROC_DRBD" ]] && CMD="up"
	einfon "Setting drbd parameters "
	COMMANDS=`$DRBDADM -d $CMD all` || { 
		eend 20 "Error executing drbdadm"
		return 20 
	}
	IFS_O=$IFS
	NEWLINE='
'
	IFS=$NEWLINE
	local D=0
	local S=0
	local N=0

	echo -n "[ "
	
	for CMD in $COMMANDS; do
		if echo $CMD | grep -q disk; then echo -n "d$D "; D=$(( D+1 ));
		elif echo $CMD | grep -q syncer; then echo -n "s$S "; S=$(( S+1 ));
		elif echo $CMD | grep -q net; then echo -n "n$N "; N=$(( N+1 ));
		else echo echo -n ".. ";
		fi
		IFS=$IFS_O
		$CMD || {
			echo 
			eend 20 "cmd $CMD failed!"
			return 20
		}
		IFS=$NEWLINE
	done
	echo "]"
	eend 0
	
	IFS=$IFS_O
}

# alt status-based waiting
_wait(){
	local s1="" s=`$* status`
	while true; do
		echo -n "."
		sleep 10
		s1=`$* status`
		[[ "$s1" == "$s" ]] && break
		s="$s1"
	done
	echo "$2~ "
	return 0
}

standalone(){
	case "`$* cstate`" in
	StandAlone*) return 0 ;;
	esac
	return 1
}

unsafe(){
	local i s=`$* cstate`
	for i in 1 0; do
		case "$s" in
		*SyncS*|*MapS*) ;;
		*Sync*|*Map*)
			echo -n "$2$s "
			[[ "$i" == 0 ]] && return 0
			_wait $*
		;;
		esac
	done
	return 1
}

# node configured to be only SyncSource (master/slave dual-primary)
# overcoded to avoid stacked (unsure)
only_source(){
	$* show|grep "^[ 	]*after-sb-0pri"|grep -qv "^[ 	]*after-sb-0pri[ 	]*discard-remote;" && return 1
	$* show|grep "^[ 	]*after-sb-1pri"|grep -qv "^[ 	]*after-sb-1pri[ 	]*violently-as0p;" && return 1
	$* show|grep -q "^[ 	]*after-sb-0pri[ 	]*discard-remote;" || return 1
	$* show|grep -q "^[ 	]*after-sb-1pri[ 	]*violently-as0p;" || return 1
	return 0
}

primary(){
	local r s=`$* cstate`
	if ! only_source $* ; then
	[[ -z "$DRBD_WAIT_PRIMARY" ]] && _wait $* || case "$s" in
	SyncSource*|StandAlone*|WFConnection*) echo -n "$2$s " ;;
	*)
		$* $DRBD_WAIT_PRIMARY
		r=$?
		echo -n "$2w$? "
	;;
	esac
	fi
	for s in 1 1 0 ; do
		r=1
		unsafe $* && continue
		$* primary
		r="$?"
		echo -n "$2p$r "
		[[ "$r" == 0 ]] && return 0
		sleep $s
	done
	[[ "$r" == 17 ]] || return $r
	[[ "$DRBD_FORCE_PRIMARY" == "yes" ]] || return $r
	if ! standalone $*; then
		unsafe $* && return 1
		$* disconnect
		echo -n "$2d$? "
		sleep 1
		standalone $* || return 1
	fi
	$* primary -o
	r="$?"
	echo -n "$2f$r "
	$DRBDADM connect minor-$2
	echo -n "$2c$? "
	return $r
}

wait_sync(){
	local i cmd ipid pid p s break="....."
	while read -n 1 i; do
		break="${break#?}${i:-.}"
		[[ "$break" == "break" ]] && killall /sbin/drbdsetup
		echo "=== status (say 'break' to stop '/sbin/drbdsetup'): ==="
		ps -o pid,time,command -C drbdsetup
		cat $PROC_DRBD
	done <&2 &
	ipid=$!
	$DRBDADM -d wait-connect all|{
		pid=""
		while read cmd i p s; do
			[[ "$p" == "wait-connect" ]] || continue
			{
			if [[ "$DRBD_HIDE_WAIT" == "yes" ]]; then
				$cmd $i $p $s
				echo -n "${i}C$? "
			fi
			[[ -z "$DRBD_WAIT_SYNC" ]] && _wait $cmd $i || $cmd $i $DRBD_WAIT_SYNC
			echo -n "${i}W$? "
			} &
			pid="$pid $!"
		done
		wait $pid
	}
	$DRBDADM -d sh-b-pri all|{
		pid=""
		while read cmd i p s; do
			[[ "$p" == "primary" ]] || continue
			primary "$cmd" "$i" &
			pid="$pid $!"
		done
		wait $pid
	}
	kill $ipid
}


remerge(){
	EGIT_OFFLINE=1 KERNEL_DIR="/usr/src/linux-`uname -r`" emerge -1q --nodeps "${1:+=}sys-cluster/drbd-kernel${1:+-$1}"
	return $?
}

v3(){
	echo ".$1."|sed -e 's:\.:\..:g' -e 's:\.\([0-9]\)\.:.00\1.:g' -e 's:\.\([0-9][0-9]\)\.:.0\1.:g'
}

# try to rebuild & reload most equal module version
# FIXME: need to check protocol version
chk_ver(){
	local v v1
	if [[ "$DRBD_EMERGE_MODULE" == "upgrade" ]]; then
		v=`grep -o "^version: [^ ]*" $PROC_DRBD`
		v="${v#version: }"
		v1=`$DRBDADM -V|grep "^DRBDADM_VERSION="`
		v1="${v1#*=}"
		( [[ -z "$v" ]] || [[ -z "$v1" ]] || ! [[ "$(v3 $v1)" > "$(v3 $v)" ]] ) && return 0
	else
		v1=`$DRBDADM sh-nop 2>&1|grep "userland version:"|sed -e 's%^.*userland version: %-%'`
		[[ -z "$v1" ]] && return 0
	fi
	$RMMOD drbd || return 0
	$RMMOD lru_cache
	if [[ -z "$1" ]]; then
		einfo "Trying to emerge equal module version ($v1)..."
		remerge "$v1-*" || remerge "$v1" || return 1
	else
		einfo "Trying to emerge latest module version..."
		remerge || return 1
	fi
	$RMMOD drbd
	$RMMOD lru_cache
	assure_module_is_loaded
	return 1
}

start() {
	local i
	einfo "Starting DRBD resources:"
	eindent
	if [[ "$DRBD_EMERGE_MODULE" == "yes" ]] || [[ "$DRBD_EMERGE_MODULE" == "upgrade" ]]; then
		if ! assure_module_is_loaded ; then
			einfo "modprobe drbd failed. Trying to emerge..."
			remerge
			chk_ver || chk_ver 1
		else
			chk_ver
		fi
	elif [[ "$DRBD_EMERGE_MODULE" == "force" ]]; then
		local v=$(echo /var/db/pkg/sys-cluster/drbd-8*|sed -e 's:^/var/db/pkg/sys-cluster/drbd-::')
		if ! ( [[ -e "/lib/modules/`uname -r`/block/drbd.ko" ]] && assure_module_is_loaded 1 ); then
			remerge "$v"
			$RMMOD drbd
			assure_module_is_loaded 1 || return $?
		fi
	fi
	assure_module_is_loaded || return $?
	adjust_with_progress || return $?

	# make sure udev has time to create the device files
	ebegin "Waiting for udev device creation ..."
	for RESOURCE in `$DRBDADM sh-resources`; do
		for DEVICE in `$DRBDADM sh-dev $RESOURCE`; do
			UDEV_TIMEOUT_LOCAL=$UDEV_TIMEOUT
			while [ ! -e $DEVICE ] && [ $UDEV_TIMEOUT_LOCAL -gt 0 ] ; do
				sleep 1
				UDEV_TIMEOUT_LOCAL=$(( $UDEV_TIMEOUT_LOCAL-1 ))
			done
		done
	done
	eend 0

	ret=0
	if [[ "$DRBD_HIDE_WAIT" != "yes" ]]; then
		einfon "Waiting for connection "
		$DRBDADM wait-con-int
		ret=$?
		echo
	fi

	einfon "Waiting & become primary if configured (key2status) [ "
	wait_sync|cat
	echo "]"

	eend $ret
	return $ret
}

isdown(){
			$DRBDADM -d down all|while read c m s; do
				if [[ -e "/dev/drbd$m" ]]; then
				echo "==$m"
					eend 1
					return 1
				fi
			done
			return 0
}

stop() {
	ebegin "Stopping all DRBD resources"
	
	# Check for mounted drbd devices, controlled by config
	local c m s
	for DEVICE in `$DRBDADM sh-dev all`; do
		if grep -q '^$DEVICE ' /proc/mounts &>/dev/null ; then
			einfo "drbd devices mounted, please umount them before trying to stop drbd!"
			eend 1
			return 1
		fi
	done
	ret=0
	if [ -e ${PROC_DRBD} ]; then
		$DRBDADM down all
		ret="$?"
		if [[ "$DRBD_RMMOD" == yes ]]; then
			${RMMOD} drbd
			ret="$?"
		else
			${RMMOD} drbd 2>/dev/null
			for DEVICE in `$DRBDADM sh-dev all`; do
				if [[ -e "$DEVICE" ]]; then
					einfo "drbd device '$DEVICE' still active"
					eend 1
					return 1
				fi
			done
		fi
	fi
	eend $ret
	return $ret
}

status() {
	# NEEDS to be heartbeat friendly...
	# so: put some "OK" in the output.
	
	if [ -e $PROC_DRBD ]; then
		ret=0
		ebegin "drbd driver loaded OK; device status:"
		eend $ret
		cat $PROC_DRBD
	else
		ebegin "drbd not loaded"
		ret=3
		eend $ret
	fi
	return $ret
}

reload() {
	ebegin "Reloading DRBD"
	$DRBDADM adjust all
	ret=$?
	eend $ret
	return $ret
}
