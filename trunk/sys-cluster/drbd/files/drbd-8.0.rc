#!/sbin/runscript
# Copyright 1999-2007 Gentoo Foundation
# Distributed under the terms of the GNU General Public License, v2 or later
# $Header: /var/cvsroot/gentoo-x86/sys-cluster/drbd/files/drbd-8.0.rc,v 1.5 2007/11/12 00:18:35 xmerlin Exp $

opts="${opts} reload"

DEFAULTFILE="/etc/conf.d/drbd"
DRBDADM="/sbin/drbdadm"
PROC_DRBD="/proc/drbd"
MODPROBE="/sbin/modprobe"
RMMOD="/sbin/rmmod"
UDEV_TIMEOUT=10
ADD_MOD_PARAM=""
DRBD_WAIT_SYNC="wait-sync --wait-after-sb --outdated-wfc-timeout=5 --degr-wfc-timeout=5 --wfc-timeout=5"
DRBD_WAIT_PRIMARY="wait-sync --wait-after-sb --outdated-wfc-timeout=0 --degr-wfc-timeout=0 --wfc-timeout=0"
DRBD_CLIENTS="heartbeat ocfs2"

if [ -f $DEFAULTFILE ]; then
  . $DEFAULTFILE
fi

depend() {
	use logger
	need net
	before $DRBD_CLIENTS
	after sshd
}

# Just in case drbdadm want to display any errors in the configuration
# file, or we need to ask the user about registering this installation
# at http://usage.drbd.org, we call drbdadm here without any IO
# redirection.
$DRBDADM sh-nop

function assure_module_is_loaded() {
	[ -e "$PROC_DRBD" ] && return
	ebegin "Loading drbd module"
	ret=0

	$MODPROBE -s drbd `$DRBDADM sh-mod-parms` $ADD_MOD_PARAM || ret=20
	eend $ret
	return $ret
}

function adjust_with_progress() {
	IFS_O=$IFS
	NEWLINE='
'
	IFS=$NEWLINE
	local D=0
	local S=0
	local N=0

	einfon "Setting drbd parameters "
	COMMANDS=`$DRBDADM -d adjust all` || { 
		eend 20 "Error executing drbdadm"
		return 20 
	}
	echo -n "[ "
	
	for CMD in $COMMANDS; do
		if echo $CMD | grep -q disk; then echo -n "d$D "; D=$(( D+1 ));
		elif echo $CMD | grep -q syncer; then echo -n "s$S "; S=$(( S+1 ));
		elif echo $CMD | grep -q net; then echo -n "n$N "; N=$(( N+1 ));
		else echo echo -n ".. ";
		fi
		IFS=$IFS_O
		$CMD || {
			echo 
			eend 20 "cmd $CMD failed!"
			return 20
		}
		IFS=$NEWLINE
	done
	echo "]"
	eend 0
	
	IFS=$IFS_O
}

primary(){
	local r=`$1 $2 cstate`
	case "$r" in
	SyncSource*|StandAlone*) echo -n "$2$r " ;;
	*)
		$1 $2 $DRBD_WAIT_PRIMARY
		echo -n "$2w$? "
	;;
	esac
	for r in 1 2 3; do
		$1 $2 primary
		r="$?"
		echo -n "$2p$r "
		[[ "$r" == 0 ]] && return 0
		sleep 1
	done
	[[ "$r" == 17 ]] || return $r
	[[ "$DRBD_FORCE_PRIMARY" == "yes" ]] || return $r
	$1 $2 primary -o
	r="$?"
	echo -n "$2f$r "
	return $r
}

wait_sync(){
	local i cmd ipid pid p s break="....."
	while read -n 1 i; do
		break="${break#?}${i:-.}"
		[[ "$break" == "break" ]] && killall /sbin/drbdsetup
		echo "=== status (say "break" to stop waiting): ==="
		cat /proc/drbd
	done <&2 &
	ipid=$!
	drbdadm -d wait-connect all|{
		pid=""
		while read i; do
			cmd="${i%% wait-connect*}"
			[[ "$cmd" == "$i" ]] && continue
			$cmd $DRBD_WAIT_SYNC &
			pid="$pid $!"
		done
		wait $pid
		echo -n "*w$? "
	}
	drbdadm -d sh-b-pri all|{
		pid=""
		while read cmd i p s; do
			[[ "$p" == "primary" ]] || continue
			primary "$cmd" "$i" &
			pid="$pid $!"
		done
		wait $pid
	}
	kill $ipid
}

start() {
	local i
	einfo "Starting DRBD resources:"
	eindent
	if ! assure_module_is_loaded ; then
		einfo "modprobe drbd failed. Trying to emerge..."
		KERNEL_DIR="/usr/src/linux-`uname -r`" emerge -1q --nodeps drbd-kernel
		assure_module_is_loaded || return $?
	fi
	adjust_with_progress || return $?

	# make sure udev has time to create the device files
	ebegin "Waiting for udev device creation ..."
	for RESOURCE in `$DRBDADM sh-resources`; do
		for DEVICE in `$DRBDADM sh-dev $RESOURCE`; do
			UDEV_TIMEOUT_LOCAL=$UDEV_TIMEOUT
			while [ ! -e $DEVICE ] && [ $UDEV_TIMEOUT_LOCAL -gt 0 ] ; do
				sleep 1
				UDEV_TIMEOUT_LOCAL=$(( $UDEV_TIMEOUT_LOCAL-1 ))
			done
		done
	done
	eend 0

	einfon "Waiting for connection "
	$DRBDADM wait-con-int
	ret=$?
	echo

	einfon "Waiting & become primary if configured (key2status) [ "
	wait_sync|cat
	echo "]"

	eend $ret
	return $ret
}

stop() {
	ebegin "Stopping all DRBD resources"
	
	# Check for mounted drbd devices
	if ! grep -q '^/dev/drbd' /proc/mounts &>/dev/null; then
		if [ -e ${PROC_DRBD} ]; then
			${DRBDADM} down all
			sleep 3
			${RMMOD} drbd
		fi
		ret=$?
		eend $ret
		return $ret
	else
		einfo "drbd devices mounted, please umount them before trying to stop drbd!"
		eend 1
		return 1
	fi
}

status() {
	# NEEDS to be heartbeat friendly...
	# so: put some "OK" in the output.
	
	if [ -e $PROC_DRBD ]; then
		ret=0
		ebegin "drbd driver loaded OK; device status:"
		eend $ret
		cat $PROC_DRBD
	else
		ebegin "drbd not loaded"
		ret=3
		eend $ret
	fi
	return $ret
}

reload() {
	ebegin "Reloading DRBD"
	${DRBDADM} adjust all
	ret=$?
	eend $ret
	return $ret
}
