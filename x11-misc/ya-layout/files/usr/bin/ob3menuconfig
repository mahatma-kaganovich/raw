#!/usr/bin/perl
# (c) Denis Kaganovich, Anarchy or GPLv2
# openbox config pipe menu v0.4
# using /usr/share/openbox*/rc.xsd

%xml_=('<'=>'lt','>'=>'gt',"'"=>'apos','"'=>'quot','&'=>'amp');
$xml_=join('',keys %xml_);
$sep=':';
$MENU='config';
#$sel='+';

$SIG{__DIE__}=sub{
return if(!exists($ENV{DBUS_SESSION_BUS_ADDRESS}));
print STDERR ($e=join('',"$0: ",@_));
exec('/usr/bin/notify-send','-t',6000,$e);
};

sub utf8_encode{};
sub utf8_decode{};
if(1){ # perl version?
	*utf8_encode=*utf8::encode;
	*utf8_decode=*utf8::decode;
#	$filemode=':utf8';
}

for(@ARGV){
	if($_=~s/^--//){
		undef $P{$i=$_};
	}else{
		push(@{$P{$i}},$_);
	}
}

if($prof=$P{profile}->[0]){
	$cfg="$ENV{HOME}/.config/$prof";
	@rc=("$cfg/rc.xml","/etc/xdg/$prof/rc.xml");
}else{
	if(!($cfg=$P{config}->[0])){
		$i=`obxprop --root`;
		$i=~s/_OB_CONFIG_FILE\(UTF8_STRING\) = \"(\S*)\"/$cfg=$1;''/se;
	}
	@rc=($cfg);
	($cfg=~s/[^\/]*$//) &&
	(($prof)=$cfg=~/.*\/([^\/]+)\/*$/) || die "Detecting openbox config";
}

my (%type,%xsd,%fontcfg,%fonts,%fonts_);

$cmd="$0 --profile $prof";

%nomenu=(
	"ob${sep}openbox_config"=>0,
);

%cmd=(
'fix'=>\&fixrc,
# todo
'app'=>sub{
#	open_(my $F,'<',"$ENV{HOME}/.cache/$prof/menu.xml");
#	read($F,my $s,-s $F);
	open_(my $F,'|-',"/usr/bin/ob3menu-cache /usr/bin/ob3menu --slow $ENV{HOME}/.config/ya/rc.xml");
	$s=join('',<$F>);
	close($F);
	utf8_decode($s);
	$s=~s/(<menu id=[\'\"])/$1$$:/gs;
	~s/([$xml_])/\&$xml_{$1};/g for(@_);
	my $p=join("' '",@_);
	$s=~s/(<action.*?<\/action>)/
		my $i=$1;
		$i=~s\/([$xml_])\/\&$xml_{$1};\/g;
		"<action name='execute'><execute>$cmd --fix '$i' '$p'<\/execute><\/action>"
	/gse;
	print $s;
	exit;
},
'fonts'=>sub{
	fonts();
	submenu(\%fonts,undef,@_);
},
);

sub load_xml{
	read($_[0],my $s,-s $_[0]) || die $!;
	close($_[0]);
	utf8_decode($s);
	### bugfix
	if($_[1]){
		$s=~s/name=\"monitor\" type=\"ob:primarymonitor\"/name=\"primaryMonitor\" type=\"ob:primarymonitor\"/;
		$s=~s/:enumeration value=\"\[0-/:pattern value=\"[0-/;
	}
	### /bugfix
	$s=~s/<!--.*?-->//gs;
	$s=~s/<\?.*?\?>//gs;
	my @tag=({});
	$s=~s/<([\/!]?)([^<>\s\/]*)([^<>]*?)(\/?)>([^<]*)/
	    my $c;
	    my $i=1;
	    if($1 eq '\/'){
		pop @tag;
		$c=$tag[-1];
	    }else{
		push @tag,$c=\%{$tag[-1]->{0}->{$2}->{$3}};
		if($4 || $1){
			$c=pop @tag
		}elsif(exists($c->{1})){
			$i=scalar(keys %$c)+!exists($c->{0})
		}
	    };
#	    $c->{$i}.=$5;
	    if(my ($x)=$5=~\/^\s*(\S.*?)\s*$\/s){ $c->{$i}.=$c->{$i} ne ''?' '.$x:$x; }
	''/ges;
	$tag[0]->{0};
}

sub sort_xsd{
	for my $t(keys %{$_[0]}){
		for my $a(keys %{$_[0]->{$t}}){
			my $id=$_[1];
			my $i=$a;
			my %a;
			$i=~s/([^=\s]+)(?:=\"([^=\"]*)\"|=\'([^=\']*)\'|)/$a{$1}=$2;''/gse;
			$id.=$sep.$a{'name'} if(exists($a{'name'}));
			$type{$id}=$a{'type'} if(exists($a{'type'}));
			while(my ($x,$y)=each %a){
				push @{$xsd{$t}->{$id}->{$x}},$y;
			}
			sort_xsd($_[0]->{$t}->{$a}->{0},$id);
		}
	}
}

sub sort_tags{
	for my $t(sort keys %{$_[0]}){
		my $id="$_[1]$sep$t";
		my $i1=$t;
		my $submenu;
		$i1=~s/_/-/g;
		if(exists($nomenu{$id})){
			next if($nomenu{$id});
#			print "<separator label='$i1'/>";
		}else{
			$conf++;
			$submenu="<menu id='$MENU:$conf' label='$i1'>";
		}
		my $A=scalar(keys %{$_[0]->{$t}})>1;
		for my $aa(sort keys %{$_[0]->{$t}}){
			my $a1=$aa;
			$a1=~s/^\s+//s;
			$a1=~s/\s+$//s;
			my $ed=$_[2];
			my $i=$t.$aa;
			if($i ne ''){
				$i=~s/([$xml_])/\&$xml_{$1};/g;
				$ed.=" \&apos;&lt;$i&gt;&apos;";
			}
			$a1=1;
			if($a1&&=$A){
				$i=$aa;
				$i=~s/_/-/g;
				$i=~s/([$xml_])/\&$xml_{$1};/gs;
				$a1&&=!exists($nomenu{$id});
				if($a1){
					print $submenu;
					$conf++;
					$submenu="<menu id='$MENU:$conf' label='$i'>"
				}else{
					print "<separator label='$i'/>"
				}
			}
			my $r=ref($type{$id});
			if($r || !($type{$id}=~/^[a-z]/)){
				print $submenu;
				$submenu=undef;
			}
			for(sort{$a<=>$b}keys %{$_[0]->{$t}->{$aa}}){
			    if(!$_){
				sort_tags($_[0]->{$t}->{$aa}->{0},$id,$ed);
			    }elsif(($d=$_[0]->{$t}->{$aa}->{$_}) ne ''){
				~s/([$xml_])/\&$xml_{$1};/gs for($d);
				my $def="<separator label='$sel$d'/>";
				if($r eq ARRAY){
					for(@{$type{$id}}){
						if($_ eq $d){
							($i,$def)=($def);
						}else{
							$i="<item label='$_'><action name='Execute'><execute>$cmd --fix &quot;$_&quot; $ed &quot;$d&quot;</execute></action></item>"
						}
						utf8_encode($i);
						print $i;
					}
				}elsif($r eq HASH){
					for(sort keys %{$type{$id}}){
						my $x=$i=$type{$id}->{$_};
						($i,$x)=@{$i} if(ref($i));
						if($d=~/^$_$/){
							($i,$def)=("<separator label='$sel$x'/>");
						}else{
							$i="<item label='$x'><action name='Execute'><execute>$cmd --fix &quot;$i&quot; $ed &quot;$d&quot;</execute></action></item>"
						}
						utf8_encode($i);
						print $i;
					};
				}elsif(defined($submenu)){
					$i=$ed;
					# "<menu exec=" broken <cr>/spaces
					$i=~s/(\s)/'&#'.ord($1).';'/gse;
					$def=substr($submenu,0,-1)." execute='$cmd --$type{$id} $i &apos;$d&apos;'/>";
				}elsif(substr($type{$id},0,1) eq '<'){
					$def=$type{$id};
				}
				if(defined($def)){
					utf8_encode($def);
					print $def;
				}
			    }
			}
			$a1 && print '</menu>';
		}
		exists($nomenu{$id}) || $submenu || print '</menu>';
	}
}

sub fontconfig{
	for(@_){
		next if(defined($fontcfg{$_}));
		$fontcfg{$_}++;
		if(stat($_) && -f && -r _ && -s _){
			my $d=$_;
			$d=~s/[^\/]*$//;
			sort_fonts(load_xml(open_(my $F,'<',$_)),$d)
		}
	}
}

sub walk{
	my $x=$_[1];
	ref($_[0])?defined($x)?ref($x)?map{walk($_[0]->{$_},@_[2..$#_])}(grep(/$x->[0]/,keys %{$_[0]})):walk($_[0]->{$x},@_[2..$#_]):$#_?map{walk($_[0]->{$_},@_[2..$#_])}(keys %{$_[0]}):($_[0]):$#_?():($_[0]);
}

sub sort_fonts{
	for(walk($_[0],'fontconfig',undef,undef,'include',undef,undef)){
		next if(ref($_));
		my $f=$_;
		$f="$_[1]$f" if(substr($f,0,1) ne '/');
		fontconfig($f,"$f.conf",glob('[0-9][0-9]-$f.conf'),glob("$f/[0-9][0-9]-*.conf"))
	}
	for(walk($_[0],'fontconfig',undef,0,'alias',undef,0)){
		next if(ref($_) ne 'HASH');
		my @a=walk($_,undef,undef,0,undef,undef,undef);
		for my $x (walk($_,'family',undef,undef)){
			next if(ref($x) || exists($fonts{quotemeta($x)}));
			for my $y (@a){
				$fonts_{$x}->{quotemeta($y)}='*' if(!ref($y));
			}
		}
	}
	for(walk($_[0],'fontconfig',undef,0,'match',['\starget=["\']pattern["\']'],0)){
		next if(ref($_) ne 'HASH');
		my @a=walk($_,'edit',['\sname=["\']family["\']'],0,'string',undef,undef);
		for my $x (walk($_,'test',['\sname=["\']family["\']'],0,'string',undef,undef)){
			next if(ref($x) || exists($fonts{quotemeta($x)}));
			for my $y (@a){
				$fonts_{$x}->{quotemeta($y)}='~' if(!ref($y));
			}
		}
	}
}

sub open_{
	open($_[0],$_[1]?$_[1].$filemode:$_[1],$_[$_]) && return $_[0] for(2..$#_);
	die "Error open '".join('|',@_[2..$#_])."'\n";
}

sub fixrc(){
$qm=0;
open_(my $F,'<',@rc);
mkdir($cfg)||die $! if(! -d $cfg);
read($F,$s,-s $F)||die $!;
utf8_decode($s);
print "$rc[0]";
close($F);
my ($from,$to);
$to=shift;
if(substr($_[-1],0,2) ne '</'){
	$from=pop(@_);
}
my $rc1=$rc[0].'.$$$';
my ($p1,$p2);
for(@_){
	my $x=$_;
	if(substr($x,0,2) ne '</'){
		$x=~s/\s.*/>/s;
		substr($x,1,0)='/';
		$p2=($qm?quotemeta($x):$x).'.*?'.$p2;
		$p1.='.*?'.($qm?quotemeta($_):$_);
	}else{
		$p2=($qm?quotemeta($x):$x).'.*?'.$p2;
	}
}
#without g this is normal
#($s=~s/($p1.*?)$from(.*?$p2)/$1$to$2/s) || die "Not found\n";
#but this safest
($s=~s/($p1)(.*?)($p2)/
	my @x=($1,$2,$3);
	$x[1]=~s\/$from\/$to\/s or die "Not found";
	join('',@x)
/se) || die "Not found";
utf8_encode($s);
open_($F,'>',$rc1) && print($F $s) && close($F) && rename($rc1,$rc[0]) || die $!;
exec('/usr/bin/openbox','--reconfigure');
exit;
}

sub fonts{
~s/^(?:.*:\s)?(.+):.*$/$fonts{quotemeta($1)}=[$1,$1]/e for(split(/\n/,`/usr/bin/fc-list`));
if(!$?){
	fontconfig('/etc/fonts/fonts.conf');
	for(my ($n,$n1)=(1); $n ne $n1; ($n,$n1)=(scalar(%fonts),$n)){
		for(keys %fonts_){
			for my $i (keys %{$fonts_{$_}}){
				if(exists($fonts{$i})){
					my $x=$fonts{$i}->[1];
					$x=~s/[^\*\~]*//;
					$fonts{quotemeta($_)}=[$_,"$_ ".delete($fonts_{$_})->{$i}.$x];
					last
				}
			}
		}
	}
}
%fonts_=();
}

sub xsd{
sort_xsd(@_);
for my $t (keys %xsd){
	for (keys %{$xsd{$_}}){
		$type{$_}=$_ if(!exists($type{$_}));
	}
}
for(keys %{$xsd{'xsd:union'}}){
	for my $i (map{split(/\s+/,$_)}(@{$xsd{'xsd:union'}->{$_}->{'memberTypes'}})){
		for my $t(keys %xsd){
			push @{$xsd{$t}->{$_}->{'value'}}, @{$xsd{$t}->{$i}->{'value'}} if(exists($xsd{$t}->{$i}));
		}
	}
}
$_->{'value'}=[sort @{$_->{'value'}}] for(values %{$xsd{'xsd:enumeration'}});
$xsd{'xsd:enumeration'}->{'ob:bool'}->{'value'}={'(?:yes|true|on)'=>'on','(?:no|false|off)'=>'off'};
for (values %type){
    for(ref($_)?@$_:$_){
	if(exists($xsd{'xsd:pattern'}->{$_})){
		my %e;
		if(ref($xsd{'xsd:enumeration'}->{$_}->{'value'}) eq 'ARRAY'){
			$e{quotemeta($_)}=$_ for(@{$xsd{'xsd:enumeration'}->{$_}->{'value'}});
		}
		for(@{delete($xsd{'xsd:pattern'}->{$_})->{'value'}}){
			$i=$_;
			$i=~s/\[([a-z])([a-z])\]/$1/gsi;
			if($i=~/[\[\]\{\}\*\.\|\+]/){
#				$enum=(); last;
				next;
			}
			$e{$_}=$i;
		}
		$xsd{'xsd:enumeration'}->{$_}->{'value'}=\%e;
	}
	$_=$xsd{'xsd:enumeration'}->{$_}->{'value'};
    }
}
for(0..2){
    for(keys %type){
	if(exists($xsd{'xsd:element'}->{$_})){
		for my $i (@{$xsd{'xsd:element'}->{$_}->{'type'}}){
			for my $ii (grep(/^$i$sep.*/,keys %type)){
				my $t=$ii;
				$t=~s/^$i//;
				$type{$_.$t}=$type{$ii};
			}
		}
	}
    }
}
%xsd=();
}

sub menu{
	$MENU.=":$_[1]";
	print '<openbox_pipe_menu>';
	sort_tags(@_);
	print '</openbox_pipe_menu>';
}

sub submenu{
	$nomenu{"$_$sep"}=0;
	$type{"$_$sep"}=shift;
	my $x=shift;
	$x={''=>{''=>{1=>pop @_}}} if(!$x);
	my $p="'".join("' '",@_)."'";
	$p=~s/([$xml_])/\&$xml_{$1};/gs;
	menu($x,$SUBMENU=$_,$p);
	exit;
}

###########################################
for(keys %P){
	&{$cmd{$_}}(@{$P{$_}}) if(exists($cmd{$_}));
}


xsd(load_xml(open_($F,'<',reverse glob('/usr/share/doc/openbox*/rc.xsd')),1),'ob');

$type{join($sep,'ob','openbox_config','theme','name')}=[(map{substr($_,18,-10)}glob('/usr/share/themes/*/openbox-3')),'/dev/null'];
$type{join($sep,'ob','openbox_config','theme','font','size')}=[(5..32)];

$type{join($sep,'ob','openbox_config','theme','font','name')}='fonts';

#fonts();
#$type{join($sep,'ob','openbox_config','theme','font','name')}=\%fonts;


menu(load_xml(open_($F,'<',@rc)),'ob');
