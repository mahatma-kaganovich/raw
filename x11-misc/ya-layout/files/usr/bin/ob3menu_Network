#!/usr/bin/perl
# (c) Denis Kaganovich, Anarchy or GPLv2
# Network manager OpenBox pipe menu v0.2
#
# This is very initial version...
#
# Fast runtime operations. No deep configuring, just start/stop wifi, configured ppp, dhcpcd
# on empty interfaces. DNS (resolv.conf) updating only if .head & .tail exists and some magic.
# Default route - only if none exists (only first). Devices and operations showed only if I
# think it [possible] enabled now, others - hidden.
#
# For root - wifi information changed runtime, for users - via "sudo rescan" [and after
# operations - todo].
#
# Primary for normal portable users, who just want fast accessibility for everyday operations.
#
# TODO:
# - improve check IP/network visibility (route) for current resolv.conf & pptp|tonnels;
# - other tonnels;
# - keys (via gtkdialog? or terminal+bash?);
# - filter visible wifi over current keyset;
# - root -> user notification;
# - bluetooth;
# - bridges (for VM, IMHO just connect/disconnect to active bridge).

use bigint;

$NOTIFY=2; # 0 - none; 1 - libnotify||terminal; 2 - terminal||libnotify; 3 - only terminal

$AUTO=$>||$ENV{OB3MENUNET_USER}; # do some auto-ops: iface up/down. disable for root.

$SIG{__DIE__}=sub{
	$SIG{__DIE__}=sub{};
	unshift @_,"$0: ";
	notify(@_);
	&_waitkey;
};

sub _waitkey{
	$SUDO || return;
	print "\nPress enter...";
	my $i=<STDIN>;
}

sub notify{
print STDERR "\n",@_;
if(exists($ENV{DBUS_SESSION_BUS_ADDRESS}) && !($SUDO && $NOTIFY>1)){
	($>,$))=($ENV{OB3MENUNET_USER},$ENV{OB3MENUNET_GRP}) if($SUDO);
	@x=($bin.'notify-send','-t',6000,join('',@_));
	$ENV{OB3MENUNET_DEBUG}?system(@x):exec(@x);
}
}

delete($ENV{DBUS_SESSION_BUS_ADDRESS}) if($NOTIFY==3);
$notify=$NOTIFY&&exists($ENV{DBUS_SESSION_BUS_ADDRESS});

$btppp='ya-bluetooth-gprs';

sub xml{
	~s/([	\n<>\'\"\&\\])/'&#'.ord($1).';'/gse for(@_);
	join(' ',@_);
}

sub _iwhelp{
	my $NNN="(?:\"[^\"]*\"|'[^']*'|[^'\"\\s]*)";
	$iw=1;
	for $i(split(/\n/,_getprg('iwconfig --help 2>&1'))){
	$i=~s/^\s*interface\s+(\S+)\s+(.*?)\s*$/
		xml(my $x=$1); my $o=$2;
		my $op=quotemeta($1);
		my @v;
		for(keys %iw){
			if(exists($iw{$_}->{$x})){
				push @v,$_;
			}
		}
		@v=($x) if(!@v);
		if($o=~s\/^\{(.*)\}$\/$1\/s){
#			$mult{$x}=$mult{$v}=1;
		}
		for my $v (@v){
			while(($o=~s\/^\|?((?:[^\|\[\]]*(?:\[.*?\])?)*)\/$op=$1;''\/es) && $op ne ''){
				$op=~s\/\[\/ *(?:\/;
				$op=~s\/\]\/) ?\/;
				next if($op eq '...');
				$op=~s\/\.\/\\.\/g;
				my $n;
				$op=~s\/N\/$n++;'N'\/gse;
				if($n==3 && ($op=~s\/NNN\/$NNN\/s)){
				}elsif($n==1){
					if($x eq 'ap'){
						$op='(?:[0-9A-Fa-f]{2}:)*[0-9A-Fa-f]{2}'
					}else{
						$op=~s\/N\/$n++;'[0-9\.]+ ?'\/ge;
					}
				}elsif($n){
					$op=~s\/N\/$n++;'[0-9]'\/ge;
				}
				$iw{$v}->{$x}->{$op}=undef;
			}
		}
	''/e;
	}
	$current=_iwdata($i=_getprg('iwconfig 2>/dev/null'),undef,1);
}

sub _iwdata{
my $r;
my $pr=$_[1]||'\s';;
my $if1;
for(split(/\n/,$_[0])){
	if($_[2]){
		~s/^(\S+)/$if_{$if1=$1}=''/se;
		next if($if1 ne $if);
	}
	for my $s(keys %iw){
		$s||next;
		for my $o(keys %{$iw{$s}}){
			my $pt=_iwpattern($s,$o);
			$pt="$pr(?:${s})[:=] *($pt)";
			my $i=$_;
			$i=~s/$pt/
#				$r->{$s}->{$o}=$1;
				$r->{$s}->{$o}=exists($r->{$s}->{$o})?"$r->{$s}->{$o} $1":$1;
			' '/gsei;
		}
	}
}
$r;
}

sub _iwpattern{
	my $p=join('|',keys %{$iw{$_[0]}->{$_[1]}});
	$mult{$_[0]}?"(?:$p,)*(?:$p)":"(?:$p)";
}

sub _ex{
	xml(my $i=$_[0],my $l=$_[-1]);
	"<item label='$l'><action name='execute'><execute>$id $i</execute></action></item>\n";
}

sub _cur{
	xml(my $i=$_[0]);
	"<separator label='*$i'/>"
}

sub _undef{
	xml(my $i=$_[0]);
	"<separator label='$i'/>"
}

sub _menu{
	xml(my $i=$_[0],my $l=$_[-1]);
	"<menu id='$id $i' label='$l' execute='$id $i'/>\n";
}

sub _menu1{
	xml(my $i=$_[0],my $l=$_[-1]);
	"<menu id='$id $i' label='$l'>\n";
}

%iw=(
	'Mode'=>{'mode'=>{}},
	'Channel'=>{'channel'=>{}},
	'Tx-Power'=>{'txpower'=>{}},
	'Frequency'=>{'freq'=>{}},
	'ESSID'=>{'essid'=>{}},
	'RTS thr'=>{'rts'=>{}},
	'Fragment thr'=>{'frag'=>{}},
	'Encryption key'=>{'key'=>{}},
	'Power Management'=>{'power'=>{}},
	'Retry  long limit'=>{'retry limit'=>{}},
	'Address|Access Point'=>{'ap'=>{}},
	'Bit Rates?|Bit Rate'=>{'rate'=>{},'bit'=>{}},
#	'Retry  long lifetime'=>{'retry lifetime'=>{}},
	''=>{'commit'=>{}},
);

sub _read{
	open(my $F,'<',$_[0])||return;
	read($F,my $s,$_[1]||-s $F);
	close($F);
	$s;
}

%noerr=(
	'pppd'=>{1280=>1,1536=>1},
	$ENV{SHELL}=>{4096=>1,1280=>1,1536=>1},
);

# ip, mask, gw, dev, vmask
sub ip2n{
	my @i=@_;
	my $x255='((?:1?[0-9]{1,2}|2[0-4][0-9]|25[1-5]))';
	my $b6='([0-9a-z]{4}|)';
	for(@i[0,1,2,5,6]){
		if(!defined($_)){
		}elsif($_=~s/^$x255\.$x255\.$x255\.$x255$/hex(sprintf('%02x%02x%02x%02x',$1,$2,$3,$4))/e){ # ipv4
			$i[4]=0xFFFFFFFF;
		}elsif($_=~s/^([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/hex($4.$3.$2.$1)/ie){ # /proc/net/route
			$i[4]=0xFFFFFFFF;
		}elsif($_=~s/^\[?([0-9a-z:]+)\]?$/$1/i){
			~s/(^|:)([0-9a-z]{1,3})(:|$)/$1.sprintf('%04s',$2).$3/gei;
			while(length($_)<39){
				$_=~s/::/::0000:/ or last;
			}
#			~s/::/:/;if(length($_)!=39){$_=undef;next;}
			~s/://g;
			if(length($_)!=32){
				$_=undef;
				next;
			}
			$_=hex($_);
			$i[4]=0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
#		}elsif($i[4]==0xFFFFFFFF && ($_=~/^[0-9]{1,2}$/i)){
#			my $x=32-hex($_);
#			$_=($i[4]>>$x)<<$x;
		}elsif($_=~/^[0-9a-z]{2}$/i){
			my $x=128-hex($_);
			$_=($i[4]>>$x)<<$x;
		}else{
			$_=undef;
		}
	}
	$i[1]=$i[4] if(!defined($i[1]));
	@i;
}

sub routestat{
	my $F;
	if(open($F,'<','/proc/net/if_inet6')){
		while(<$F>){
			chomp($_);
			~s/.*\s+//gs;
			$if_ip{$_}=1;
		}
		close($F);
	}
	if(open($F,'<','/proc/net/ipv6_route')){
		while(<$F>){
			chomp($_);
			~s/.*\s+//gs;
			$if_ip{$_}=1;
			my @a=split(/\s+/,$_);
			ip2n($a[0],$a[1],$a[4],$a[9],$a[2],$a[3]);
		}
		close($F);
	}
	if(open($F,'<','/proc/net/route')){
		while(<$F>){
			$_=~s/(\S+)\s+([0-9A-F]{8})\s+([0-9A-F]{8})\s+\S+\s+\S+\s+\S+\s+\S+\s+([0-9A-F]{8})/push @route,[ip2n($2,$4,$3,$1)];''/sei;
		}
	}elsif(open($F,'-|','route -n')){
		while(<$F>){
			$_=~s/([0-9\.]+)\s+([0-9\.]+)\s+([0-9\.]+)\s+.*(\S+)\s*$/push @route,[ip2n($1,$2,$3,$4)];''/se;
		}
	}
	for(@route){
		$default_route+=!$_->[0] && !$_->[1];
		$if_ip{$_->[3]}=undef;
	}
	$F && close($F);
}

# a in b
sub ip_in{
	my $v=$_[0]->[4];
	$v == $_[1]->[4] &&
#	($_[0]->[0] & $_[0]->[1]) >= ($_[1]->[0] & $_[1]->[1])
	$_[0]->[0] >= $_[1]->[0]
	&& ($_[0]->[0] | ($_[0]->[1] ^ $v)) <= ($_[1]->[0] | ($_[1]->[1] ^ $v))
}

sub n2ip{
	my $x=sprintf('%08x',$_[0]);
	my $X='([0-9a-zA-Z]{2})';
	$x=~s/^$X$X$X$X$/hex($1).'.'.hex($2).'.'.hex($3).'.'.hex($4)/ge;
	$x;
}

sub checkroute{
	my @r;
	for(@route){
		my $x1=n2ip($_->[0] | ($_->[1]^0xFFFFFFFF));
		my $x2=n2ip($_[0] | ($_[1]^0xFFFFFFFF));
		push @r,$_ if(ip_in([@_],$_));
	}
	$r;
}

my @ID=('ESSID','Frequency','Channel','Address|Access Point');

sub _getprg{
	my $cmd=$_[0];
	my $n=$cmd;
	$n=~s/\s+/ /gs;
	$n=~s/\W/_/gs;
	$n="$ENV{HOME}/.cache/ya/net.$n.tmp";
	my $s;
	if($>){
		open(my $F,'<',$n)||return;
		flock($F,1);
		read($F,$s,-s $F);
		close($F);
	}else{
		if($AUTO && (my ($if)=$_[0]=~/^iwlist+\s+(\S+)/) && _read("/sys/class/net/$if/carrier",1) eq ''){
			$cmd="$cmd || ( ifconfig $if up && ( $cmd || ( sleep 1 && $cmd ) ; ifconfig $if down ) )";
		}
		print "#:$AUTO:$ENV{OB3MENUNET_USER} $cmd\n" if($ENV{OB3MENUNET_DEBUG});
		$s=`$cmd`;
	}
	if($if eq ''){
		$tmp{$n}=undef;
		open(my $F,'>>',$n)||die "$n: $!";
		flock($F,2);
		chown(@USER,$F);
		seek($F,0,0);
		truncate($F,0);
		print $F $s;
		close($F);
	}
	$s;
}

# visually waiting, but closing window don't affect process
sub can_background{
	return if($WAIT_++);
	$SIG{CHLD}='IGNORE';
	my $i=fork();
	$i || return;
	print "\nWaiting:";
	waitpid($i,0);
}

sub rescan{
	if($SUDO){
		&can_background && return;
		print " rescanning...";
	}
	$if=undef;
	@USER=($ENV{OB3MENUNET_USER},$ENV{OB3MENUNET_GRP});
	$ENV{HOME}=$ENV{OB3MENUNET_HOME};
	_iwhelp();
	_getprg("iwlist $_ scanning 2>&1") for(keys %if_);
	for("$ENV{HOME}/.cache/ya/net.*.tmp"){
		exists($tmp{$_})||unlink $_;
	}
	exit;
}

sub _resolv{
	my $r={};
	open(my $F,'<','/etc/resolv.conf'.$_[0])||return @r;
	while(<$F>){
		~s/^\s*([a-z]*)\s+[0-9\.]*\s*$/$r->{$1}->{$2}=undef/esi;
	}
	close($F);
	$r;
}

sub resolvstat{
	my $r=_resolv();
	for(_resolv('.head'),_resolv('.tail')){
		for my $x(keys %$_){
			delete($r->{$x}->{$_}) for(keys %{$_->{$x}});
		}
	}
	if((!$default_route) && -e '/etc/resolv.conf.head' && -e '/etc/resolv.conf.tail'){
		checkroute(ip2n($_)) || delete($r->{'nameserver'}->{$_}) for(keys %{$r->{'nameserver'}});
	}
	$enable_ch_resolv=!scalar(%$r);
}

sub aplist{
	pop @_;
	$id=join(' ',$0,@_);
	my $i=_getprg("iwlist $if scanning 2>&1");
	my $keys=join('|',keys %{$iw{'Encryption key'}->{'key'}});
	if(!$! && index($i,'Cell')>=0){
		print '<separator label="'.$header.join(',',map{join('|',keys %{$iw{$_}})}@ID).'"/>';
		my @res;
		for(split(/\n\s*Cell\s+/s,$i)){
			my %v;
			$_=~s/^(\S+)\s+-\s+/$v{cell}=$1;''/se or next;
			my $v=_iwdata("\n ".$_);
			$v || next;
			my $avail=!grep(/(?:$keys)/,values %{$v->{'Encryption key'}});
			my ($i,$s,$sep,$cur);
			for(@ID){
				next if(!exists($v->{$_}));
				for my $x(values %{$v->{$_}}){
					$x=~s/\s//gs if(!($x=~/\"/));
					$s.=",$x";
				}
				for my $o (keys %{$v->{$_}}){
					# current "Channel" don't visible in "iwconfig"
					# ignore list?
					if($o ne 'Channel'){
					$cur&&=$current->{$_}->{$o} eq $v->{$_}->{$o};
					}
					$i.="$o $v->{$_}->{$o} "
				}
			}
			$s=substr($s,1);
			$res[$avail].=$cur?_cur($s):_ex($i,$s);
		}
		print $res[0];
		$res[$_] && print '<separator/>',$res[$_] for(1..$#_);
	}
}

sub btpath{
	my $i=_run("dbus-send --system --dest=org.bluez --print-reply / org.bluez.Manager.FindAdapter string:$_[0]");
	my ($p)=$i=~/object path \"(.*?)\"/s;
	$p||die "DBUS: org.bluez.Manager.FindAdapter($_[0]) empty answer\n";
}

# devel
sub btnet{
	while(my ($a,$d)=each %btdev){
		$btpath{$a}=btpath($d);
	}
	while(my ($a,$p)=each %btpath){
		if($_[0]){
			my $net=`dbus-send --system --dest=org.bluez --print-reply $p org.bluez.NetworkServer.Unregister string:nap`;
#			my $net=`dbus-send --system --dest=org.bluez --print-reply $p org.bluez.NetworkServer.Register string:nap string:$_[0]`;
			print STDERR "nap:$net\n\n";
#			for my $uuid('gn','panu','nap'){
#				print "===$uuid===\n";
#				my $net=`dbus-send --system --dest=org.bluez --print-reply $p org.bluez.NetworkServer.Register string:$uuid string:$_[0]`;
#				print STDERR "$uuid:$net\n\n";
#			}
		}
#return;
		for my $c(keys %{$btname{$a}}){
			my $x=$c;
			$x=~s/:/_/gs;
			for my $uuid('gn','panu','nap'){
				print "dbus-send --system --dest=org.bluez --print-reply $p/dev_$x org.bluez.Network.Connect string:$uuid\n";
				my $net=`dbus-send --system --dest=org.bluez --print-reply $p/dev_$x org.bluez.Network.Connect string:$uuid string:what`;
#				print STDERR "$uuid:$net\n\n";
#				my $net=`dbus-send --system --dest=org.bluez --print-reply $p/dev_$x org.bluez.Network.GetProperties`;
#				print STDERR "$uuid:$net\n\n";
			}
		}
	}
}

sub btstat{
	for(glob('/sys/class/bluetooth/*')){
		my $d=$_;
		$d=~s/.*\///gs;
		my $a=_read("$_/address",32);
		chomp($a);
		my $u=_read("$_/uevent",1024);
		if($u=~/(?:^|\n)DEVTYPE=link(?:\n|$)/){
			$c=$a;
			$a=_read("$_/device/address",32);
			chomp($a);
			$btlink{$d}=$c;
#			$btconn{$a}->{$c}->{$d}=undef;
			for(glob("$_/rfcomm*")){
				~s/.*\///gs;
				$rfcomm{$a}->{$c}->{$_}=
				$rfcomm_{$_}=$btname{$a}->{$c}||$c;
			}
			next;
		}
		$btdev{$a}=$d;
		$btdev_{$d}=$a;
		my $dir="/var/lib/bluetooth/$a";
		if(open(my $F,'<',"$dir/names")){
			while(<$F>){
				chomp($_);
				my ($c,$n)=split(/\s+/,$_,2);
				$btname{$a}->{$c}=$n;
			}
			close($F);
		}
		if(open(my $F,'<',"$dir/linkkeys")){
			while(<$F>){
				~s/^$are/$btkey{$1}=1/e;
			}
			close($F);
		}
	}
	my $a;
	($a)=(keys %btdev) if(scalar(keys %btdev)==1);
	for(glob("/sys/class/tty/rfcomm*")){
		my $r=$_;
		$r=~s/.*\///gs;
		if(!exists($rfcomm_{$r})){
			my $c=_read("$_/address");
			chomp($c);
			$rfcomm{$a}->{$c}->{$r}=
			$rfcomm_{$r}=$btname{$a}->{$c}||$c;
		}
	}
#	scalar(%btdev)||return;
	$rf=0;
	while(exists($rfcomm_{"rfcomm$rf"})){$rf++};
	$rf="rfcomm$rf";
	if(defined($if)){
		our $a=$btdev_{$if};
		$id="$0 $if";
		$APN=1;
		if(open(my $F,'-|',"hcitool -i $if con")){
			while(<$F>){
				my ($c)=$_=~/$are/ or next;
				$btconn{$a}->{$c}=$btname{$a}->{$c};
			}
			close($F);
		}
	}
}

sub btmodem{
	my ($a,$c,$ch)=@_;
	my $cmd;
	my $p=$btppp;
	if($APN){
		$p.='-apn';
		$cmd.='echo;read -p APN: APN;export APN;';
	}
	# we can check to restart ppp on existing closed connection, but simplify behaviour:
	# if ppp broken - something wrong. better to restart whole
	if(exists($rfcomm{$a}->{$c})){
		my $d=$btdev{$a};
		return ("rfcomm -i $a release $d",'stop: ');
	}
	if(!defined($ch)){
		$ch='$ch';
		$cmd.='ch=`sdptool search --bdaddr '.$c.' 0x1103|grep Channel` && ch=${ch##*Channel:} && ';
	}
	("$ENV{SHELL} -c \"${cmd}rfcomm -i $a bind $rf $c $ch && [ -e /dev/$rf ] && exec pppd $rf call $p$ppp1\"");
}

sub pppstat{
	if($default_route){
		$ppp1.=' nodefaultroute';
		$ppp2.=' !gw';
	}
	if($enable_ch_resolv){
		$ppp1.=' usepeerdns';
	}else{
		$ppp2.=' !dns';
	}
	$ppp1.=' debug nodetach' if($ENV{OB3MENUNET_DEBUG});
	for(glob('/var/run/ppp*.pid')){
		open(my $F,'<',$_)||next;
		my $p=<$F>;
		chomp($p);
		close($F);
		open($F,'<',"/proc/$p/cmdline")||next;
		my $s=<$F>;
		close($F);
		my @a=split(/\x0/,$s);
		$i=$_;
		$i=~s/^.*\/(.*?)\.pid$/$1/g;
		for(0..$#a-1){
			if($a[$_] eq 'call'){
				$pppd{$a[$_+1]}=$p;
				$ppp{$a[$_+1]}=$i;
			}
		}
		$devppp{$a[1]}=$i;
		$fd{readlink($_)}=undef for(glob('/proc/$p/fd/*')); # root
	}
}

sub ifstat{
	for(glob('/sys/class/net/*')){
		$i=$_;
		$i=~s/.*\///g;
#		next if($i eq 'lo');
		my $w=-e "$_/wireless";
		$iw+=$w;
		push @wlan,$i if($w);
		$carrier{$i}=_read("$_/carrier",1);
		if(-e "$_/bridge"){
			$bridge{$i}=[];
			for(glob("$_/brif")){
				~s/.*\///g;
				push @{$bridge{$i}},$_;
			}
		}
		next if(exists($if_ip{$i}) && !-e "/var/run/dhcpcd-$i.pid");
		$if{$i}=1;
	}
}

%btservice=(
	'0x1103'=>{'modem'=>\&btmodem},
);

$are='((?:[0-9a-zA-Z]{2}:){5}[0-9a-zA-Z]{2})';

$ENV='^(?:OB3MENUNET_.*|DBUS_SESSION_BUS_ADDRESS|DISPLAY)$';

%carr=(
'0'=>' -',
'1'=>' +',
''=>' ?',
);

%submenu=(
'iwconfig ap'=>sub{
	_iwhelp();
	for(keys %{$iw{'Address|Access Point'}->{'ap'}}){
		print _ex($_) if(!($_=~/[\[\(\|]/));
	}
	aplist(@_);
},
#'hcitool scan'=>sub{btscan(@_);},
'sdptool browse'=>sub{
	routestat();
	resolvstat();
	pppstat();
	btstat();
	_btbrowse($_[2]);
},
'hcitool con'=>sub{
	routestat();
	resolvstat();
	pppstat();
	ifstat();
	btstat();
	my $c=$_[2];
	my $h=`hcitool -h`;
	for(exists($btconn{$a}->{$c})?('dc','auth','key'):('cc','con+auth')){
		my $i;
		if($_ eq 'con+auth'){
			print _ex("$ENV{SHELL} -c \"hcitool -i $if cc $c && hcitool -i $if auth $c\"","Connect & auth");
			next;
		}elsif(($i)=$h=~/\n\s*$_\s+([^\n]*)/s){
		}else{
			$i=$_;
		}
		print _ex("hcitool -i $if $_ $c",$i);
	}
	# sdptool browse slow, then keep in separate menu
	# todo: decode /var/lib/.../sdp file
#	print '<separator label="Services:"/>'; _btbrowse($c);
	print _menu("sdptool $c browse","Services");
},
);

sub _run{
	print "[run:$>] # $_[0]\n";
	$out=`$_[0] 2>&1`;
	print "$out";
	$? && die "$_[0]:$? $!\n$out\n";
	$out;
}

%sudo=(
'-NAP'=>sub{
	($if)=@_;
	my $p=btpath($if);
	_run("dbus-send --system --dest=org.bluez --print-reply $p org.bluez.NetworkServer.Unregister string:nap");
	0;
},
'NAP'=>sub{
	($if,$br)=@_;
	my $p=btpath($if);
	if(!defined($br)){
		$br=0;
		while(exists($bridge{"br$br"})){$br++};
		$br="br$br";
		_run("(brctl addbr $br && ifconfig $br promisc up)");
		$? && return $?;
	}
	_run("dbus-send --system --dest=org.bluez --print-reply $p org.bluez.NetworkServer.Register string:nap string:$br");
	0;
},
);

sub _btbrowse{
	my $c=$_[0];
	open(my $F,'-|',"sdptool -i $if browse $c")||return;
	my @s=({});
	$i=undef;
	while(<$F>){
		chomp($_);
		if($_ eq ''){
			push @s,{};
			$i=undef;
			next;
		}
		$_=~s/^(\S.*?):/$i=$1;''/e;
		push @{$s[-1]->{$i}},$_;
	}
	close($F);
	for(@s){
		my $n=join(',',@{$_->{'Service Name'}});
		my %i;
		my $ch;
		~s/^\s*Channel:\s*(\d+)\s*$/$ch=$1/e for(@{$_->{'Protocol Descriptor List'}});
		~s/\((0x[0-9a-z]*)\)/$i{$1}=1/gie for(@{$_->{'Service Class ID List'}});
#		print _ex("$ch:$n ".join(',',keys %i));
		for my $s(sort keys %i){
			if(exists($btservice{$s})){
				for my $sn(sort keys %{$btservice{$s}}){
					my @r=&{$btservice{$s}->{$sn}}($a,$c,$ch);
					$r[1].="$ch:$n ($sn)";
					print _ex(@r);
				}
			}else{
				print _undef("$ch:$n ($s)");;
			}
		}
	}
}

sub netmenu{
	my @cmd;
	if($>){
		$ENV{OB3MENUNET_HOME}=$ENV{HOME};
		$ENV{OB3MENUNET_USER}=$>;
		$ENV{OB3MENUNET_GRP}=$);
		$ENV{OB3MENUNET_GRP}=~s/\s.*//gs;
	}
	if($SUDO=($_[0] eq '--sudo')){
		delete($ENV{DBUS_SESSION_BUS_ADDRESS}) if($NOTIFY==2);
		$notify=$NOTIFY; # now we can notify in sudo'ed terminal
		shift;
		if($_[0] eq '--rescan'){
			rescan(@_);
			exit;
		}
		@cmd=@_;
		goto SUDO;
	}
	if($_[0] eq '--debug'){
		shift;
		$ENV{OB3MENUNET_DEBUG}=1;
	}
	my $i;
	$if=$_[0];
	$ENV{OB3MENUNET_DEBUG}=($if=~s/^\+//)||$ENV{OB3MENUNET_DEBUG};
	$id=xml($0,my @xxx=@_);
	if($#_<0){
		routestat();
		resolvstat();
		pppstat();
		ifstat();
		print '<openbox_pipe_menu>';
		for(sort keys %if){
			print _menu(($ENV{OB3MENUNET_DEBUG}?'+':'').$_,$_.$carr{$carrier{$_}});
		}
		for(glob('/etc/ppp/peers/*')){
			$i=$_;
			$i=~s/.*\///g;
			if(exists($pppd{$i})){
				print _ex("_ kill $pppd{$i}","$ppp{$i} stop $i") if($i ne $btppp);
			}else{
				my ($default_route,$enable_ch_resolv)=($default_route,$enable_ch_resolv);
				defined($d=_read($_))||next;
				$debugppp{$i}=$ENV{OB3MENUNET_DEBUG};
#				$debug=1 if($d=~/\n\s*debug(\s|$)/);
				$debugppp{$i}=1 if($d=~/\n\s*nodetach(\s|$)/);
				# todo: if pptp goes via default network - CAN replace default network, but keep destination subnet
				if($d=~s/^pty\s+\"pptp\s+(\S+).*/$1/gs){
					# todo: resolve host $d
					my @r=checkroute(ip2n($d));
					next if(!@r);
					my %if;
					for(@route){
						$if{$_[3]}++ if(!($_->[0] && $_->[1]));
					}
					for(@r){
						delete($if{$_[3]}) if($_->[0] && $_->[1]);
					}
					if(!scalar(%if)){
						$default_route=0;
					}
					$d="pptp $i ($d)";
				}elsif($d=~s/^pty\s+\"pppoe\s(?:.*\s)?-I\s+(\S+)\s.*/$1/gs){
					next if(!$carrier{$d});
					$default_route-=(!$_->[0] && $_[3] eq $i) for(@routes);
					$d="pppoe $i ($d)";
				}else{
					$d=~s/\s.*//gs;
					next if(!($d && (!-e "/var/lock/LCK..$d") && -e "/dev/$d"));
					$d="ppp $i";
					$devppp{$d}=$i;
				}
				$i="_ pppd call $i$ppp1";
				$d.="$ppp2";
				print _ex(($debugppp{$i}?'+':'').$i,$d);
			}
		}
		btstat();
		my %bt;
		for(sort values %btdev){
			print _menu($_);
		}
		for my $a (keys %rfcomm){
			for my $c (keys %{$rfcomm{$a}}){
				for(keys %{$rfcomm{$a}->{$c}}){
					my $n=$btname{$a}->{$c};
					push @{$bt{$n}},_ex("$_ rfcomm release $_","$_ stop $devppp{$_} \"$n\"");
				}
			}
		}
		my $chat='/usr/sbin/chat';
		$chat.=' -V' if($ENV{OB3MENUNET_DEBUG});
		for my $a(keys %btname){
			while(my ($c,$n)=each %{$btname{$a}}){
				exists($rfcomm{$a}->{$c}) && next;
				my @r=btmodem($a,$c);
				push @{$bt{$n}},_ex("$rf $r[0]","$r[1] $rf pppd $ppp2 \"$n\"");
			}
		}
		print '<separator/>';
		my ($sc,$sc1,$sc2,$sc3,$sc4);
		for(values %btdev){
			$sc1.="hciconfig $_ up;hciconfig $_ piscan;";
			$sc2.="hcitool -i $_ inq & hcitool -i $_ scan &";
			$sc3.=";hciconfig $_ noscan";
			$sc4.=";(hcitool -i $_ con|grep -q ACL || hciconfig $_ down)"
		}
		$sc="$sc1 $sc2 simple-agent $sc3 $sc4;false";
		print _menu("--debug",'debug') if(!$ENV{OB3MENUNET_DEBUG});
		print _ex("_ $ENV{SHELL} -c \\\"$sc\\\"", 'Bluetooth ON - scan & agent - OFF') if(-e '/usr/bin/simple-agent');
		if($iw){
			if($>){
				die 'Security problem' if(substr($0,0,1) ne '/');
				$i=join(' ',map{"$_=\"$ENV{$_}\""}grep(/$ENV/,keys %ENV));
				$id="ya-session --run +sudo -p $0:root:password: $i $id";
				print _ex("--sudo --rescan",'Wi-Fi rescan');
			}
			_iwhelp();
			for(@wlan){
				next if(!$AUTO && $carrier{$_} eq '');
#				$carrier{$_} && next;
				$header="$_ ";
				$if=$_;
				aplist($_,'iwconfig',$_,'ap')
			}
		}
		if(scalar(%bt)){
				for my $k(" label='Bluetooth modems'",undef){
					print "<separator$k/>",map{$btkey{$_} ne $k?(sort @{$bt{$_}}):()}sort keys %bt;
				}
		}
		print '</openbox_pipe_menu>';
		exit;
	}elsif(!$#_){
		routestat();
		resolvstat();
		print '<openbox_pipe_menu>';
		my $d="/sys/class/net/$if";
		if(!-e $d){
			if(-e ($d="/sys/class/bluetooth/$if")){
				btstat();
				print _menu1('NAP server to bridge');
				print _ex("NAP $if $_","$_: ".join(' ',@{$bridge{$_}})) for(sort keys %bridge);
				print _ex("NAP $if",'Create new');
				print _ex("-NAP $if",'Unregister (if any)');
				print '</menu>';
				print '<separator label="Bluetooth devices"/>';
				my %bt;
				$bt{"$btname{$a}->{$_} $_"}=$_ for(keys %{$btname{$a}},keys %{$btconn{$a}});
				for(sort keys %bt){
					my $c=$bt{$_};
					print _menu("hcitool $c con",(exists($btconn{$a}->{$c})?'+':'-').$_);
				}
			}
			goto EX;
		}
		if(defined($i=_read("/var/run/dhcpcd-$if.pid",32))){
			print _ex("kill $i",'stop dhcp');
		}else{
			my $p=$ENV{OB3MENUNET_DEBUG}?'Bd':'bq';
			if($default_route){
				$p.='G';
				$i.=' !gw';
			}
			if(!$enable_ch_resolv){
				$p.=' -C resolv.conf';
				$i.=' !dns';
			}
			print _ex("dhcpcd -$p $if","start dhcp$i");
		}
		if(-e "$d/wireless"){
			print '<separator label="Wi-Fi"/>';
			my $i;
			_iwhelp();
			my %o;
			for my $s(keys %iw){
				for my $o(keys %{$iw{$s}}){
					if(!$s){
						$o{$o}.=_ex("iwconfig $if $o",$o);
						next;
					}
					my $d=$current->{$s}->{$o};
					my $t=$o;
#					$t=lc($s) eq $t?$s:"$s ($t)";
					my $def;
					if(defined($d)){
						$t.="  $d";
						$def=_cur($d);
					}
					if($o eq 'ap'){
						$o{$o}.=_menu("iwconfig $if $o","$t:") if(scalar(%{$iw{'Address|Access Point'}->{'ap'}}));
						next;
					}
					$i.=_menu1("iwconfig $if $o",$t);
					my $n;
					for(sort keys %{$iw{$s}->{$o}}){
						next if($_=~/[\[\(\|]/);
						$n++;
						if(lc($d) eq lc($_)){
							$i.=$def;
							$def=undef;
						}else{
							$i.=_ex("iwconfig $if $o $_",$_);
						}
					}
					$i.=$def.'</menu>';
					$o{$o}.=$i if($n);
					$i='';
				}
			}
			print map{$o{$_}}sort keys %o;
		}
EX:
		print '</openbox_pipe_menu>';
		exit;
	}else{
		for([1],[1,3],[1,4],[1,2],[1,2,3]){
			if($#_ == $_->[-1] && ($i=$submenu{join(' ',@_[@$_])})){
				print '<openbox_pipe_menu>';
				&{$i}(@_);
				print '</openbox_pipe_menu>';
				exit;
			}
		}
		@cmd=@_[1..$#_];
		for(@cmd){
			~s/^ap_$/ap/;
		}
	}
SUDO:
	die "Illegal --sudo context\n" if($SUDO && (!@cmd || $>));
	if(@cmd){
		my %cmd;
		$cmd{$_}=1 for(@cmd);
		if(!$SUDO && $>){
			for(@cmd){
				$_="\"$_\"" if($_=~/[\s\*\?]/);
			}
			my $cmd=join(' ',@cmd,'--  root password:');
#			$cmd=quotemeta($cmd);
			$cmd=~s/([\"\'\\])/\\$1/gs;
			if($notify){
				die 'Security problem' if(substr($0,0,1) ne '/');
				unshift @cmd,$0,'--sudo';
				unshift @cmd,map{"$_=\"$ENV{$_}\""}grep(/$ENV/,keys %ENV);
				$cmd="[ob3menunet] $cmd";
			}
			@cmd=('ya-session','--run',join(' ','+sudo','-p',"\"$cmd\"",@cmd));
		}
#		$iw=$SUDO && ($iw || $cmd{'iwconfig'}); # rescan if iwconfig+sudo
		$iw=$SUDO; # rescan as possible
		$iw&&=!$cmd{'kill'};
		$notify||=$iw;
		my $out;
		if($i=$sudo{$cmd[0]}){
			$r=&{$i}(@cmd[1..$#cmd]);
		}elsif($notify){
			$r=system(@cmd);
#			for(@cmd){
#			}
#			$cmd=join(' ',@cmd);
#			$out=`( $cmd ) 2>&1`;
#			$r=$?;
		}else{
			$r=exec(@cmd);
		}
		$cmd||=join(' ',@cmd);
		$r && die "$cmd\nError: $cmd[0]:$r $!\n$out\n";
		rescan() if($iw);
		$ENV{OB3MENUNET_DEBUG} && (!$cmd{'kill'}) && _waitkey();
		if($out ne ''){
			notify("$cmd\n$out\n");
		}elsif($notify && !$>){
			notify("OK\n$cmd\n");
		}
		exit $i;
	}
}

sub _m{
	my $i=shift;
	my $p=join(' ',@_);
	$i=~s/( execute=\')([^\']*\')/$1$p $2/gs;
	$i=~s/(<menu id=\')([^\']*\')/$1$p $2/gs;
	$i=~s/(<execute>)([^[<>]*<\/execute>)/$1$p $2/gs;
	$i;
}

#btstat();
#btnet('br0');
#exit;

netmenu(@ARGV);
