#!/sbin/runscript
# Copyright 1999-2007 Gentoo Foundation
# Distributed under the terms of the GNU General Public License, v2 or later
# $Header: /var/cvsroot/gentoo-x86/sys-cluster/drbd/files/drbd-8.0.rc,v 1.5 2007/11/12 00:18:35 xmerlin Exp $

opts="${opts} reload"

DEFAULTFILE="/etc/conf.d/drbd"
DRBDADM="/sbin/drbdadm"
PROC_DRBD="/proc/drbd"
MODPROBE="/sbin/modprobe"
RMMOD="/sbin/rmmod"
UDEV_TIMEOUT=10
ADD_MOD_PARAM=""
DRBD_WAIT_SYNC="wait-sync --wait-after-sb --outdated-wfc-timeout=5 --degr-wfc-timeout=5 --wfc-timeout=5"
DRBD_WAIT_PRIMARY="wait-sync --wait-after-sb --outdated-wfc-timeout=0 --degr-wfc-timeout=0 --wfc-timeout=0"
DRBD_CLIENTS="heartbeat ocfs2"
DRBD_EMERGE_MODULE="yes"
DRBD_HIDE_WAIT="no"

if [ -f $DEFAULTFILE ]; then
  . $DEFAULTFILE
fi

depend() {
	use logger
	need net
	before $DRBD_CLIENTS
	after sshd
}

# Just in case drbdadm want to display any errors in the configuration
# file, or we need to ask the user about registering this installation
# at http://usage.drbd.org, we call drbdadm here without any IO
# redirection.
$DRBDADM sh-nop

function assure_module_is_loaded() {
	[ -e "$PROC_DRBD" ] && return
	ebegin "Loading drbd module"
	ret=0

	$MODPROBE -s drbd `$DRBDADM sh-mod-parms` $ADD_MOD_PARAM || ret=20
	eend $ret
	return $ret
}

function adjust_with_progress() {
	IFS_O=$IFS
	NEWLINE='
'
	IFS=$NEWLINE
	local D=0
	local S=0
	local N=0

	einfon "Setting drbd parameters "
	COMMANDS=`$DRBDADM -d adjust all` || { 
		eend 20 "Error executing drbdadm"
		return 20 
	}
	echo -n "[ "
	
	for CMD in $COMMANDS; do
		if echo $CMD | grep -q disk; then echo -n "d$D "; D=$(( D+1 ));
		elif echo $CMD | grep -q syncer; then echo -n "s$S "; S=$(( S+1 ));
		elif echo $CMD | grep -q net; then echo -n "n$N "; N=$(( N+1 ));
		else echo echo -n ".. ";
		fi
		IFS=$IFS_O
		$CMD || {
			echo 
			eend 20 "cmd $CMD failed!"
			return 20
		}
		IFS=$NEWLINE
	done
	echo "]"
	eend 0
	
	IFS=$IFS_O
}

# alt status-based waiting
_wait(){
	local s1="" s=`$* status`
	while true; do
		echo -n "."
		sleep 10
		s1=`$* status`
		[[ "$s1" == "$s" ]] && break
		s="$s1"
	done
	echo "$2~ "
	return 0
}

standalone(){
	case "`$* cstate`" in
	StandAlone*) return 0 ;;
	esac
	return 1
}

unsafe(){
	local i s=`$* cstate`
	for i in 1 0; do
		case "$s" in
		*SyncS*|*MapS*) ;;
		*Sync*|*Map*)
			echo -n "$2$s "
			[[ "$i" == 0 ]] && return 0
			_wait $*
		;;
		esac
	done
	return 1
}

primary(){
	local r s=`$* cstate`
	[[ -z "$DRBD_WAIT_PRIMARY" ]] && _wait $* || case "$s" in
	SyncSource*|StandAlone*|WFconnection*) echo -n "$2$s " ;;
	*)
		$* $DRBD_WAIT_PRIMARY
		r=$?
		echo -n "$2w$? "
	;;
	esac
	for s in 1 1 0 ; do
		r=1
		unsafe $* && continue
		$* primary
		r="$?"
		echo -n "$2p$r "
		[[ "$r" == 0 ]] && return 0
		sleep $s
	done
	[[ "$r" == 17 ]] || return $r
	[[ "$DRBD_FORCE_PRIMARY" == "yes" ]] || return $r
	if ! standalone $*; then
		unsafe $* && unsafe $* && return 1
		$* disconnect
		echo -n "$2d$? "
		sleep 1
		standalone $* || return 1
	fi
	$* primary -o
	r="$?"
	echo -n "$2f$r "
	$DRBDADM connect minor-$2
	echo -n "$2c$? "
	return $r
}

wait_sync(){
	local i cmd ipid pid p s break="....."
	while read -n 1 i; do
		break="${break#?}${i:-.}"
		[[ "$break" == "break" ]] && killall /sbin/drbdsetup
		echo "=== status (say 'break' to stop '/sbin/drbdsetup'): ==="
		cat /proc/drbd
	done <&2 &
	ipid=$!
	$DRBDADM -d wait-connect all|{
		pid=""
		while read cmd i p s; do
			[[ "$p" == "wait-connect" ]] || continue
			{
			if [[ "$DRBD_HIDE_WAIT" == "yes" ]]; then
				$cmd $i $p $s
				echo -n "${i}C$? "
			fi
			[[ -z "$DRBD_WAIT_SYNC" ]] && _wait $cmd $i || $cmd $i $DRBD_WAIT_SYNC
			echo -n "${i}W$? "
			} &
			pid="$pid $!"
		done
		wait $pid
	}
	$DRBDADM -d sh-b-pri all|{
		pid=""
		while read cmd i p s; do
			[[ "$p" == "primary" ]] || continue
			primary "$cmd" "$i" &
			pid="$pid $!"
		done
		wait $pid
	}
	kill $ipid
}


remerge(){
	EGIT_OFFLINE=1 KERNEL_DIR="/usr/src/linux-`uname -r`" emerge -1q --nodeps "${1:+=}sys-cluster/drbd-kernel$1"
	return $?
}

# try to rebuild & reload most equal module version
# FIXME: need to check protocol version
chk_ver(){
	local v=`$DRBDADM sh-nop 2>&1|grep "userland version:"|sed -e 's%^.*userland version: %-%'`
	[[ -z "$v" ]] && return 0
	if [[ -z "$1" ]]; then
		einfo "Trying to emerge equal module version..."
		remerge "$v-*" || remerge "$v" || return 1
	else
		einfo "Trying to emerge latest module version..."
		remerge || return 1
	fi
	rmmod drbd
	assure_module_is_loaded
	return 1
}

start() {
	local i
	einfo "Starting DRBD resources:"
	eindent
	if [[ "$DRBD_EMERGE_MODULE" == "yes" ]]; then
		if ! assure_module_is_loaded ; then
			einfo "modprobe drbd failed. Trying to emerge..."
			remerge
			chk_ver
		else
			chk_ver 1 || chk_ver
		fi
	fi
	assure_module_is_loaded || return $?
	adjust_with_progress || return $?

	# make sure udev has time to create the device files
	ebegin "Waiting for udev device creation ..."
	for RESOURCE in `$DRBDADM sh-resources`; do
		for DEVICE in `$DRBDADM sh-dev $RESOURCE`; do
			UDEV_TIMEOUT_LOCAL=$UDEV_TIMEOUT
			while [ ! -e $DEVICE ] && [ $UDEV_TIMEOUT_LOCAL -gt 0 ] ; do
				sleep 1
				UDEV_TIMEOUT_LOCAL=$(( $UDEV_TIMEOUT_LOCAL-1 ))
			done
		done
	done
	eend 0

	ret=0
	if [[ "$DRBD_HIDE_WAIT" != "yes" ]]; then
		einfon "Waiting for connection "
		$DRBDADM wait-con-int
		ret=$?
		echo
	fi

	einfon "Waiting & become primary if configured (key2status) [ "
	wait_sync|cat
	echo "]"

	eend $ret
	return $ret
}

stop() {
	ebegin "Stopping all DRBD resources"
	
	# Check for mounted drbd devices
	if ! grep -q '^/dev/drbd' /proc/mounts &>/dev/null; then
		if [ -e ${PROC_DRBD} ]; then
			${DRBDADM} down all
			sleep 3
			${RMMOD} drbd
		fi
		ret=$?
		eend $ret
		return $ret
	else
		einfo "drbd devices mounted, please umount them before trying to stop drbd!"
		eend 1
		return 1
	fi
}

status() {
	# NEEDS to be heartbeat friendly...
	# so: put some "OK" in the output.
	
	if [ -e $PROC_DRBD ]; then
		ret=0
		ebegin "drbd driver loaded OK; device status:"
		eend $ret
		cat $PROC_DRBD
	else
		ebegin "drbd not loaded"
		ret=3
		eend $ret
	fi
	return $ret
}

reload() {
	ebegin "Reloading DRBD"
	${DRBDADM} adjust all
	ret=$?
	eend $ret
	return $ret
}
