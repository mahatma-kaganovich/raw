#!/bin/sh
## pnp modules bootloader v0.14
## (c) Denis Kaganovich, under Anarchy license
## consume preprocessed /lib/modules/$KV/modules.alias

[[ -z "$TMPDIR" ]] && [[ -e /temp ]] && TMPDIR="/temp"

## millisecons
#SYS_FIND="/sys"
SYS_FIND=/sys/devices

pids=""

single(){
	grep -qF ">$1<" "${PNP_TMP}.$2" && return 1
	echo ">$1<" >>"${PNP_TMP}.$2"
	return 0
}

mod(){
	local m m1 m2
	for m in $(echo -ne "$*" | sed -e 's/-/_/g') ; do
		$CHK && {
			single "$m" 0 || continue
		}
		modalias "$m" || {
			echo ">$m<" >>"${PNP_TMP}".4
			continue
		}
		case $PARALLEL in
		no|0) ;;
		2)
			m2=""
			for m1 in $ALIAS ; do
				modparam $m1
				m2="$m2 $insmod "$m1" $PARAM ;"
			done
			eval "( ${m2%;} ) >/dev/null 2>&1 &"
			pids="$pids$! "
			continue
		;;
		*)
			pids="$pids$pid "
			pid=""
		;;
		esac
		for m1 in $ALIAS ; do
#			m="${m1##*/}"
#			[[ -e "/sys/module/${m%.ko}" ]] && continue
			modparam $m1
			wait $pid
			$cmd_quiet || echo -ne "\033[0G\033[0K$LCOUNT	$m1 $PARAM"
			$insmod "$m1" $PARAM >/dev/null 2>&1 &
			pid="$!"
		done
	done
}

refresh(){
	LCOUNT="${LCOUNT}."
	echo -ne "\033[0G\033[0K$LCOUNT"
	local i j l

	wait $pid $pids
	pid=""
	pids=""

	sed -e 's%^\([^ 	]*\)[	 ]*.*$%>\1<%g' </proc/modules >"${PNP_TMP}".1
	cat `grep -ls "^DRIVER=" $(find $SYS_FIND -name uevent -print 2>/dev/null) </dev/null` </dev/null |grep "^DRIVER=\|^MODALIAS="|sed -e 's%-%_%g' -e 's%^.*=\(.*\)$%>\1<%g' >>"${PNP_TMP}".1
	if [[ "$(cat ${PNP_TMP}.1 $checks)" == "$(cat ${PNP_TMP}.2)" ]] ; then
		cat "${PNP_TMP}".3 "${PNP_TMP}".4 >"${PNP_TMP}".0
		if ps ax|grep -q "[ 	]/sbin/mdev"; then
			REFRESH_SAME=''
			[[ "$1" == "n" ]] && REFRESH_SAME=1
			return 0
		fi
		[[ "$REFRESH_SAME$1" == "n" ]] || return 1
		return 0
	fi
	sort -u "${PNP_TMP}".1 >"${PNP_TMP}".0
	if ! $cmd_quiet ; then
		echo -ne "\033[0G\033[0K${BOLD}   ::${NORMAL}Loaded:"
		for i in $(sort -m ${PNP_TMP}.0 ${PNP_TMP}.3 | uniq -u) ; do
			[[ "$1" == "n" ]] && echo "$i" >>/nopnp.lst
			i="${i#>}"
			i="${i%<}"
			echo -ne " $i"
		done
		echo ""
	elif $cmd_unload && [[ "$1" == "n" ]] ; then
		sort -m ${PNP_TMP}.0 ${PNP_TMP}.3 | uniq -u >>/nopnp.lst
	fi
	cat "${PNP_TMP}".1 $checks >"${PNP_TMP}".2
	cp "${PNP_TMP}".0 "${PNP_TMP}".3
	cat "${PNP_TMP}".4 >>"${PNP_TMP}".0
	REFRESH_SAME=''
	[[ "$1" == "n" ]] && REFRESH_SAME=1
	return 0
}

count(){
	[[ "${LCOUNT#????????????????}" == "${LCOUNT}" ]] && return 0
	bad_msg "Deadloop?"
	return 1
}

mnt_loop(){
	if losetup $1 $2; then
		mount -o ro $1 $3 && return 0
		losetup -d $1
		return 1
	fi
	mount -o loop,ro $2 $3
	return $?
}

mod_unload(){
	local i l m=""
	cd /
	if ! [[ -e ${NEW_ROOT}/lib/modules/$KV ]] ; then
		if ${cmd_autoinstall:-false} ; then
			echo -ne "(Installing /lib/modules/$KV)"
			mount -o remount,rw ${NEW_ROOT} &&
			cp -a /lib/modules/$KV ${NEW_ROOT}/lib/modules/$KV
		else
			echo -ne '(use "autoinstall" to install modules)'
		fi
	fi
	for i in /rd /lib; do
		[[ -d "$i" ]] && umount $i && break
	done
	losetup -d /dev/loop1 >/dev/null 2>&1
	l=""
	( $cmd_unload && [[ -n "$REAL_ROOT" ]] && [[ -e "/nopnp.lst" ]] ) || return
	echo -n "(removing unlocked modules"
	while read i; do
		i="${i#>}"
		l="${i%<} $l"
	done </nopnp.lst
	i="$(cat /proc/modules)"
	while [[ "$i" != "$m" ]]; do
		m="$i"
		echo -n "."
		rmmod $l >/dev/null 2>&1
		i="$(cat /proc/modules)"
	done
	echo -n ")"
}

pnp_options(){
	PARALLEL=0
	cmd_nofb=false
	cmd_nopnp=false
	cmd_unload=false
	cmd_noraid=false
	cmd_real_init=/sbin/init
	local i v
	local p="*)PARAM='';;"
	while [[ -n "$*" ]] ; do
	i="$1"
	shift
	case "$i" in
	parallel-startup) PARALLEL=1 ;;
	parallel-startup=*) PARALLEL="${i#*=}" ;;
	moduleparam=*)
		i="${i#*=}"
		p="*/${i%%:*}.ko)PARAM=\"${i#*:}\";;$p"
	;;
	md=*)	v="cmd_${i%%=*}"
		eval "$v=\"\$$v ${i#*=}\""
	;;
	*=*)	v="${i%%=*}"
		case "$v" in
		*.*) p="*/${i%%.*}.ko)PARAM=\"${i#*.}\";;$p" ;;
		*) export cmd_`echo "$v"|sed -e 's:[^a-zA-Z0-9_]:_:g'`="${i#*=}" ;;
		esac
	;;
	*.*) p="*/${i%%.*}.ko)PARAM=\"${i#*.}\";;$p" ;;
	scandelay) cmd_scandelay=10 ;;
	*) export cmd_`echo "$i"|sed -e 's:[^a-zA-Z0-9_]:_:g'`=true ;;
	esac
	done
	$cmd_nofb && p="*/fb.ko|*/drm_kms_helper.ko|*/fbcon.ko)insmod=false;return 1;;$p"
	[[ -n "$cmd_noload" ]] && p="*/$(echo "$cmd_noload"|sed -e 's/,/.ko|*\//g').ko)insmod=false;return 1;;$p"
	echo "modparam(){
insmod=insmod
case \$1 in
1)insmod=${REORDER:-continue}
return 1;;
$p
esac
}" >/etc/modparam.sh
	$cmd_quiet && good_msg(){ return; }
}

link_dir(){
	local i
	for i in "$1"/*; do
		i="${i#$1}"
		if [[ -L "$1$i" ]] && ( [[ -L "$2$i" ]] || ! [[ -e "$2$i" ]] ) ; then
			cp "$1$i" "$2$i" -a
		elif [[ -d "$2$i" ]]; then
			if [[ -L "$2$i" ]]; then
				local d="$(readlink "$2$i")"
				rm "$2$i"
				mkdir "$2$i"
				link_dir "$d" "$2$i"
			fi
			link_dir "$1$i" "$2$i"
		elif [[ "$i" != "/*" ]]; then
			ln -sf "$1$i" "$2$i"
		fi
	done
}

pnp_init(){
	eval "pnp_options $(cat /proc/cmdline)" # parsing
	local l
	for l in /*.loopfs; do
	if [[ -f "$l" ]]; then
		echo -ne "\033[15;1f"
		for i in `find /lib/modules -name "*.ko"` ; do
			insmod $i
		done
		local d="${l%.loopfs}"
		mkdir $d 2>/dev/null
		mnt_loop /dev/loop1 $l $d
		break
	fi
	done
	[[ -d /rd ]] && link_dir /rd
	[[ -d /lib/root ]] && link_dir /lib/root

	[[ -e /lib/modules/$KV/modules.dep ]] && return
	# pnponly
	rm /sbin/modprobe
	. /etc/modprobe.sh
	override_modprobe
}

override_modprobe(){
local f="/sbin/modprobe"
[[ -e $f ]] && ! ( grep -q "bug #197730" $f && rm /sbin/modprobe ) && return
echo '#!/bin/sh
. /etc/modprobe.sh
modprobe $*
exit $?' >$f
chmod 755 $f
echo "$f" >/proc/sys/kernel/modprobe
}

wild(){
	grep "$1" <modules.other|grep -v "${2:-x--}"|sed -e 's:.*/::g' -e 's/\...$//g'
}

cpufreq(){
	[[ -n "$freq" ]] && return
	local l=""
	local CHK=false
	local w="$(wild $@)"
	for i1 in $w ; do
		mod $i1
		wait $pid $pids
		pid=""
		pids=""
		for i in `grep -ls "$i1" $(find /sys/devices/system/cpu -name scaling_driver 2>/dev/null) </dev/null | sed -e 's:/scaling_driver::g'` ; do
			read i2 <"$i/cpuinfo_transition_latency" >/dev/null 2>&1 || continue
			[[ "$i2" -gt "${l:=${i2}}" ]] && continue
			if [[ "$i2" == "$l" ]] ; then
				[[ "${freq#*${i1} }" == "$freq" ]] && freq="$freq$i1 "
			else
				freq=" $i1 "
			fi
		done
		rmmod $i1 >/dev/null 2>&1
	done
	rmmod $w >/dev/null 2>&1
}

cpufreq_gov(){
	local gov1=""
	for i1 in $gov ; do
		mod cpufreq_${i1}
		wait $pid $pids
		pid=""
		pids=""
		for i in `find /sys/devices/system/cpu -name scaling_governor 2>/dev/null` ; do
			echo $i1 >"$i" 2>/dev/null
			read i2 <"$i"
			[[ "$i2" == "$i1" ]] || gov1="$gov1 $i"
		done
		rmmod cpufreq_${i1} >/dev/null 2>&1
		[[ -z "$gov1" ]] && break
	done
}

empty_hwopts(){
	local i
	[[ -e /etc/modules ]] && for i in $* ; do
		 echo -ne "" >/etc/modules/$i
	done
}

# params: part [loop]
# out: $DETECTED_LOOPS++, $DETECTED_ROOTS++
detect_part(){
	grep -qF ">$*<" "${PNP_TMP}.5" && return 0
	local l
	wait $pid $pids
	pid=""
	pids=""
	$cmd_quiet || echo -ne "\033[0G\033[0K$LCOUNT	Inspecting: $1"
	mkdir /DETECT_ROOT || return 1
	mount -o ro "$1" /DETECT_ROOT >/dev/null 2>&1 || {
		rmdir /DETECT_ROOT
		return 1
	}
	echo ">$*<" >>"${PNP_TMP}.5"
	[[ "${2:-false}" != false ]] && for l in $( {
		if [[ "$2" == true ]]; then
			_fstype ${LOOPS_}
		else
			_fstype $2
		fi
		} | sed -e 's%^\(.*:\).* TYPE="\([^"]*\)".*$%\1\2%g'
	    ) ; do
		DETECTED_LOOPS="$DETECTED_LOOPS $1:${l#/DETECT_ROOT/}"
		l="${l#*:}"
		case "$l" in
		ext2) LOOPTYPE=normal ;;
		*) LOOPTYPE="$l" ;;
		esac
		mod $l # loop
	done
	[[ -e "/DETECT_ROOT/$cmd_real_init" ]] && grep -sq "^$1[ 	]*/[ 	]" /DETECT_ROOT/etc/mtab && DETECTED_ROOTS="$DETECTED_ROOTS $1"
#	[[ -e "/DETECT_ROOT/$cmd_real_init" ]] && DETECTED_ROOTS="$DETECTED_ROOTS $1"
	umount /DETECT_ROOT >/dev/null 2>&1
	rmdir /DETECT_ROOT
}

part_(){
	( ( [[ -b "$1" ]] && echo "$1" ) || $fstype $1 || $blkid $1 || $blkid -t "$1" || findfs "$1" || busybox findfs "$1" ) 2>/dev/null | sed -e 's:^.* TYPE="swap".*$::g' -e 's/:.*$//g'
}

detect_root(){
	local i d="${cmd_detect_root:-false}" l="$cmd_loop" fs
	[[ "$d" == true ]] && d=""
	if [[ "$d" != false ]]; then
		# if real_root & loop hard-defined - don't probe other loops
		[[ -n "$REAL_ROOT" ]] && [[ "${l:-true}" != true ]] && l=false
		# if real_root & loop hard-defined - probe all loops
#		[[ -n "$REAL_ROOT" ]] && [[ "${l:-true}" != true ]] && l=true
		for i in `part_ "$d"`; do
			case "$i" in
			/dev/loop1) ;;
			*) detect_part "$i" "$l" ;;
			esac
		done
	fi
	if [[ -n "$REAL_ROOT" ]] && [[ "${cmd_loop:-false}" != false ]]; then
		detect_part "$(part_ "$REAL_ROOT")" "$cmd_loop"
	fi
}

dhcp_get(){
	local i r=''
	for i in `busybox dmesg | grep rootserver | sed -e "s/,/ /g"`; do
		if [[ "`echo $i | sed -e "s/=/ /g" | cut -d " " -f 1`" == "$1" ]]; then
			r="`echo "$i" | sed -e "s/=/ /g" | cut -d " " -f 2`"
			# FIXME: first value will be more balanced, but last - actual in longrun
			break
		fi
	done
	echo -ne "$r"
}

# modifyed genkernel's function to support other network filesystems (/dev/<filsystem>)
findnfsmount() {
	grep -q "[ 	]${NFSLIKE_FS:=nfs}\$" /proc/filesystems || return 1
	if [[ -n "$IP" ]] || busybox udhcpc -n -T 15 -q ; then
		[ -e /rootpath ] && cmd_nfsroot=`cat /rootpath`

		if [[ -z "${cmd_nfsroot:=$(dhcp_get rootserver):$(dhcp_get rootpath)}" ]]; then
			bad_msg "The DHCP Server did not send a valid root-path."
			bad_msg "Please check your DHCP setup, or provide a nfsroot=<...> parameter."
		else
			local local o m="$NEW_ROOT"
			[[ "$CDROOT" != '0' ]] && m="$m/mnt/cdrom"
			good_msg "Attempting to mount $NFSLIKE_FS on $cmd_nfsroot into $m"
			for o in "ro,nolock,rsize=1024,wsize=1024" "ro,nolock" "ro"; do
				if mount -t $NFSLIKE_FS -o $o $cmd_nfsroot $m ; then
					# FIXME: Need to start portmap and the other rpc daemons in
					# order to remount rw.
					REAL_ROOT="/dev/nfs"
					return 0
				fi
			done
			bad_msg "$NFSLIKE_FS Mounting failed. Is the path correct ?"
		fi
	fi
	return 1
}

msg_(){
	wait $pid $pids
	pid=""
	pids=""
	if $cmd_quiet; then
		echo -ne "\033[0G"
	else
		echo -ne "\033[0G\033[0K"
		[[ -n "$*" ]] && good_msg "$*"
	fi
}

# dirty
fstype(){
local i d
[[ -z "$*" ]] && set `cat /proc/partitions|sed -e "s:^.*[ ]:/dev/:g" -e "s:^/dev/name$::"` ""
while [[ -n "$*" ]]; do
d="$1"
[[ -z "$d" ]] || [[ -e "$d" ]] || d="`findfs $1 2>/dev/null`"
! grep -s "^$d:" /etc/fstype.cache &&
( [[ -b "$d" ]] || [[ -f "$d" ]] ) && for i in 0 3 4 8 24 32 54 82 510 536 1016 1024 1040 1048 1080 1560 2048 4086 4096 8182 8192 8212 8244 9564 16374 32758 32768 32769 32777 65526 65536 65588 65600 270336; do
case "`echo -ne "$i:";hexdump -v -s $i -n 10 -e '"" 10/1 "%x" ""' $d 2>/dev/null`" in
32:4f52434c4449534b*)echo oracleasm;;
3:4e54465320202020*)echo ntfs;;
1080:53ef*)echo "jbd
ext4dev
ext4
ext3
ext2";;
8244:5265497345724673*|65588:526549734572324673*|65588:526549734572334673*|65588:5265497345724673*|8212:5265497345724673*)echo reiserfs;;
65536:52654973457234*)echo reiser4;;
65536:01161970*)echo "gfs
gfs";;
82:4d5357494e*|82:4641543332202020*|54:4d53444f53*|54:4641543136202020*|54:4641543132202020*|0:eb*|0:e9*|510:55aa*)echo vfat;;
1040:7f13*|1040:8f13*|1040:6824*|1040:7824*)echo minix;;
1024:f5fc01a5*)echo vxfs;;
0:58465342*)echo xfs;;
0:2d726f6d3166732d*)echo romfs;;
0:cefa7b1b*)echo bfs;;
0:453dcd28*)echo cramfs;;
4:514e58344653*)echo qnx4;;
32769:4245413031*|32769:424f4f5432*|32769:4344303031*|32769:4344573032*|32769:4e53523032*|32769:4e53523033*|32769:5445413031*)echo udf;;
32777:4344524f4d*|32769:4344303031*)echo iso9660;;
32768:4a465331*)echo jfs;;
8192:000002f5b007b10c*|8192:0cb107b0f5020000*|270336:000002f5b007b10c*|270336:0cb107b0f5020000*)echo zfs;;
1024:4244*|1024:482b*|1024:4858*)echo "hfsplus
hfs";;
9564:541901*)echo ufs;;
8192:49e895f9*)echo hpfs;;
1016:107e18fd*)echo sysv;;
4086:535741502d5350414345*|4086:53574150535041434532*|8182:535741502d5350414345*|8182:53574150535041434532*|16374:535741502d5350414345*|16374:53574150535041434532*|32758:535741502d5350414345*|32758:53574150535041434532*|65526:535741502d5350414345*|65526:53574150535041434532*)echo swap;;
4086:533[12]53555350454e44*|4086:554c53555350454e44*|8182:533[12]53555350454e44*|8182:554c53555350454e44*|16374:533[12]53555350454e44*|16374:554c53555350454e44*|32758:533[12]53555350454e44*|32758:554c53555350454e44*|65526:533[12]53555350454e44*|65526:554c53555350454e44*)echo swsuspend;;
8:4f7261636c65434653*)echo ocfs;;
1024:4f4346535632*|2048:4f4346535632*|4096:4f4346535632*|8192:4f4346535632*)echo ocfs2;;
0:4c554b53babe*)echo crypt_LUKS;;
0:73717368*|0:68737173*)echo squashfs;;
536:4c564d3220303031*|24:4c564d3220303031*|1048:4c564d3220303031*|1560:4c564d3220303031*|8192:4f4346535632*)echo lvm2pv;;
65600:5f42485266535f4d*)echo btrfs;;
esac|while read i; do
	echo "$d: TYPE=\"$i\""
	echo "$d: TYPE=\"$i\"" >>/etc/fstype.cache
done
done
shift
done
}

_fstype(){
	$fstype $* || $blkid $* || $blkid -t $* || echo -e "$*"
}

detect_fs(){
	local i m="" md="$USE_MDADM" dm="$USE_DMRAID_NORMAL" t="" nfs="$cmd_nfsroot" lvm="$USE_LVM_NORMAL" evms="$USE_EVMS_NORMAL"
	if $waitscan; then
		[[ -e /etc/modules/waitscan ]] || mod scsi_wait_scan
		empty_hwopts waitscan
		[[ -n "$cmd_scandelay" ]] && sleep "$cmd_scandelay"
		waitscan=false
		wait $pid $pids
		pid=""
		pids=""
		rmmod scsi_wait_scan 2>/dev/null
		/sbin/mdev -s block
	fi
	# dmraid/lvm/evms unsure
	for i in $( {
			if [[ "${cmd_detect_root:-true}" == true ]]; then
				_fstype
			else
				_fstype $cmd_detect_root
				[[ -n "$REAL_ROOT" ]] && [[ "$REAL_ROOT" != "$cmd_detect_root" ]] && _fstype $REAL_ROOT
			fi
	    } 2>/dev/null | sed -e 's:^.* TYPE="\([^"]*\)".*$:\1:g'| sort -u ); do
		case $i in
		linux_raid_member|mdraid|/dev/md*) : md=1 ;; # use right blkid
		/dev/mapper*|/dev/dm*) : dm=1 ;;
		EVMS*|evms*)
			evms=1
			dm=1
		;;
		LVM*|lvm*)
			lvm=1
			dm=1
		;;
		*raid*)
			m="$m $(wild "/$i/\|raid") $i"
			dm=1
		;;
		/dev/*)
			i="${i#/dev/}"
			m="$m $i"
			NFSLIKE_FS="$i"
			[[ "$REAL_ROOT" == "$i" ]] && REAL_ROOT=/dev/nfs # compat
		;;
		swap) ;;
		*) m="$m $(wild "/$i/") $i" ;;
		esac
	done
	[[ -n "$dm" ]] && m="$m dm-mod"
	# FIXME: IMHO it will be loaded after dmraid failure
#	[[ -n "$dm" ]] && m=$m $(wild "/md/dm-\|raid_class")"
	mod $m
	if [[ -n "$evms" ]]; then
		msg_ "Activating EVMS"
		if evms_activate ; then
			USE_EVMS_NORMAL_=""
			lvm=""
			USE_LVM_NORMAL=""
			USE_LVM_NORMAL_=""
		fi
	fi
	if [[ -n "$lvm" ]]; then
		msg_ "Activating LVM"
		if vgscan --ignorelockingfailure --mknodes 2>/dev/null ; then
			sleep 2
			vgchange -ay --ignorelockingfailure 2>/dev/null
			USE_LVM_NORMAL_=""
			evms=""
			USE_EVMS_NORMAL=""
			USE_EVMS_NORMAL_=""
		fi
	fi
	for i in $cmd_md ; do
		set `echo "$i"|sed -i -e 's:,: :g'`
		i="$1$2$3$4"
		if [[ -n "$5" ]] && [[ "${i##*/dev/}" == "$i" ]]; then
			mod "raid$2"
			i="$1 --level=$2 --chunk=$3"
			shift 4
			i="--build /dev/md$i"
		else
			mod $(wild "/md/raid")
			i="$1"
			shift
			[[ "${i#d}" != "$i" ]] && i="${i#d} --run"
			i="--assemble /dev/md$i"
		fi
		msg_
		mdadm $i --raid-devices=$# $*
	done
	if [[ -n "$md$dm" ]]; then
		# maybe dm wrong here, but try
		if [[ -e '/etc/mdadm.conf' ]]; then
			mod `( grep " level=" /etc/mdadm.conf || ( mdadm --examine --scan -v|grep " level=" ) ) | sed -e 's:^.* level=\([^ ]*\) .*$:\1:g' | sort -u`
		else
			mdadm --examine --scan -v >/etc/mdadm.conf
			mod `grep " level=" /etc/mdadm.conf | sed -e 's:^.* level=\([^ ]*\) .*$:\1:g' | sort -u`
		fi
		if [[ -n "$md" ]]; then
			msg_
			# busybox | mdadm | all raid modules
			( $cmd_noraid || mdadm --assemble || mdadm --assemble --scan ||
				( mod $(wild "/md/") ; ( mdadm --assemble || mdadm --assemble --scan ) ) ) && USE_MDADM_=""
		fi
	fi
	if [[ -e /sbin/dmraid ]] || [[ -e /usr/sbin/dmraid ]]; then
		if $cmd_noraid; then
			t=t
			msg_ "Testing Device-Mapper RAID(s)"
		else
			msg_ "Activating Device-Mapper RAID(s)"
		fi
		if dmraid -ay$t ${DMRAID_OPTS} >/dev/null ; then
			USE_DMRAID_NORMAL_=""
		else
			mod $(wild "/md/\|raid")
			msg_
			dmraid -ay$t ${DMRAID_OPTS} && USE_DMRAID_NORMAL_=""
		fi
	fi
	detect_root
	return 0
}

gentoo_compat_hwopts(){
	local i i1
	for i1 in ${MY_HWOPTS} ; do
		if [[ -e "/etc/modules/$i1" ]] ; then
			for i in `cat /etc/modules/$i1` ; do
				grep -q "^$i\$" "modules.pnp" || mod "$i"
			done
		else
			mod $(wild "/${i1}[./]")
		fi
	done
}

load_hand_made(){
	## some hand-made autoloads
	$cmd_nofb || [[ -z "$(cat /proc/fb 2>/dev/null)" ]] || mod fbcon
	while read i i1 ; do
		case $i in
#		usual_tables) mod usb_storage ;; # on demand
		usbcore) mod usb_storage ;; # user-frendly
#		thermal_sys) mod fan ;;
		esac
	done </proc/modules
	# frost. save your silicon (and power)
	# autoload cpufreq driver in price of at least one more unload
	# speedup probing by vendor & other vendor-related
	freq=`cat $(find /sys/devices/system/cpu -name scaling_driver 2>/dev/null) </dev/null`
	case "$(grep "^vendor_id" /proc/cpuinfo)" in
	*AMD*)
		cpufreq powernow
		: ${gov:=conservative ondemand}
	;;
	*Intel*) cpufreq acpi-cpufreq ;;
	*CentaurHauls*) mod via-cputemp padlock-aes padlock-sha via-rng ;;
	esac
	cpufreq cpufreq "drivers/cpufreq/\|powernow"
	[[ -z "$freq" ]] && return
	mod $freq
	${cmd_nopowersave:-false} && return
	[[ -z "$gov" ]] && if grep -sq 1 /sys/class/power_supply/BAT*/present && ! grep -sq 1 /sys/class/power_supply/AC*/online ; then
		gov="conservative ondemand"
	else
		gov="ondemand conservative"
	fi
	cpufreq_gov
	rmmod freq_table >/dev/null 2>&1
	for i in /sys/devices/system/cpu/sched_*_power_savings ; do
		[[ -e "$i" ]] && echo 2 >$i 2>/dev/null
	done
}

load_misc(){
	# do: loadall[=...] or process MY_HWOPTS
	for i in $cmd_loadall ; do
		[[ "$i" == 'true' ]] && i=''
		i1="${i%%:*}"
		i2="${i#*:}"
		[[ -z "$i1" ]] && i1=".*"
		# default: exclude slow probe, fatal to unload, etc
		[[ "$i2" == "$i" ]] && i2='/tcrypt.ko\|/paride/\|/media/\|/sound/\|/microcode\.\|/isdn/\|/net/\|/video/'
		mod $(wild "$i1" "$i2")
	done
	[[ -z "$cmd_loadall" ]] && [[ "$NODETECT" != '1' ]] && gentoo_compat_hwopts # deprecated
	detect_fs
}

set_root_loop(){
	set 1 `echo "$1"|sed -e 's/:/ /g'`
	REAL_ROOT="$2"
	LOOP="$3"
	LOOPTYPE="$4"
}

# vs. "find" optimization [dis]order
ordered_modalias(){
	local i
	[[ -e "$1/modalias" ]] && ! grep -sq "^DRIVER=." "$1/uevent" && mod `cat "$1/modalias"`
	for i in "$1"/* ; do
		[[ -d "$i" ]] && [[ ! -L "$i" ]] && ordered_modalias "$i"
	done
}

fast_modalias(){
	mod $MDOLIST `sort -u $(find $SYS_FIND -name modalias -print 2>/dev/null) </dev/null 2>/dev/null`
#	mod $MDOLIST `cat $(find $SYS_FIND -name modalias -print 2>/dev/null|sort) </dev/null 2>/dev/null|uniq`
}

syspnp(){
	[[ -e "/lib/modules/${KV}/modules.alias.sh" ]] || return
	$cmd_nopnp && return
	# +some compats
	local PNP_TMP="${TMPDIR}/pnp.found" NOTLOADED="" CHK=true i i1 i2 gov="" freq="" pid="" LCOUNT="" REORDER=break USE_MDADM_="${USE_MDADM:=$cmd_domdadm}" USE_DMRAID_NORMAL_="${USE_DMRAID_NORMAL:=$cmd_dodmraid}" USE_EVMS_NORMAL_="${USE_EVMS_NORMAL:=$cmd_doevms}" USE_LVM_NORMAL_="${USE_LVM_NORMAL:=$cmd_dolvm}" LOOPS_="" REFRESH_SAME waitscan=true checks="" fstype=fstype
	local blkid="$(which blkid 2>/dev/null || ( [[ -e /bin/blkid ]] && echo /bin/blkid ) || ( [[ -e /sbin/blkid ]] && echo /sbin/blkid ) || echo blkid )"
	[[ "${USE_DMRAID_NORMAL:-true}" != true ]] && DMRAID_OPTS="$USE_DMRAID_NORMAL"
	: ${REAL_ROOT:=$cmd_real_root}
	for i in ${LOOPS:-"/*"}; do
		LOOPS_="${LOOPS_} /DETECT_ROOT$i"
	done

	good_msg "Searching pnp"
	if [[ -e /lib/modules/$KV/modules.dep ]]; then
		# else - pnponly/init
		. /etc/modprobe.sh
		override_modprobe
	fi
	for i in 0 1 2 3 4 5; do
		echo -ne "" >"${PNP_TMP}.$i"
	done

	empty_hwopts firewire net pata pcmcia sata scsi usb   ataraid dmraid evms lvm mdadm fs
	i="$(readlink $blkid)"
	[[ -e "$blkid" ]] && [[ "${i%busybox}" == "$i" ]] && fstype=false

	refresh n
	# first pass - strict bus order
	CHK=false
	[[ -n "$MDOLIST" ]] && mod $MDOLIST
	ordered_modalias $SYS_FIND
	CHK=true
	while count && refresh; do
		fast_modalias
	done
	REFRESH_SAME=1
	checks="$checks /proc/partitions"
	while count ; do
		if [[ -n "$REORDER" ]]; then
			REORDER=""
			load_hand_made
			wait $pid $pids
			pid=""
			pids=""
		else
			fast_modalias
		fi
		$cmd_unload && refresh
		load_misc
		refresh n || break
	done

	MY_HWOPTS=""
	MDOLIST=""
	USE_MDADM="${USE_MDADM_}"
	USE_DMRAID_NORMAL="${USE_DMRAID_NORMAL_}"
	USE_LVM_NORMAL="${USE_LVM_NORMAL_}"
	USE_EVMS_NORMAL="${USE_EVMS_NORMAL_}"

	echo -ne "\033[0G\033[0K"

	# assign detected root/loop
	if [[ -z "$REAL_ROOT" ]]; then
		DETECTED_ROOTS="${DETECTED_ROOTS# }"
		DETECTED_LOOPS="${DETECTED_LOOPS# }"
		[[ "${DETECTED_ROOTS#* }" == "$DETECTED_ROOTS" ]] && DETECTED_ROOT="$DETECTED_ROOTS"
		[[ "${DETECTED_LOOPS#* }" == "$DETECTED_LOOPS" ]] && DETECTED_LOOP="$DETECTED_LOOPS"
		[[ "${cmd_loop:-true}" == true ]] && REAL_ROOT="$DETECTED_ROOT"
		( [[ "$cmd_loop" != true ]] || [[ -z "$DETECTED_ROOTS" ]] ) && [[ -z "$REAL_ROOT" ]] && set_root_loop "$DETECTED_LOOP"
		if [[ -z "$REAL_ROOT" ]]; then
			[[ -n "$DETECTED_ROOTS" ]] && bad_msg "Detected possible root devices: $DETECTED_ROOTS"
			[[ -n "$DETECTED_LOOPS" ]] && bad_msg "Detected loopbacks: $DETECTED_LOOPS"
		fi
	fi

	good_msg "Boot time: $(cat /proc/uptime)"
	if [[ -n "${NOTLOADED}" ]] ; then
		good_msg "Not loaded:$NOTLOADED"
		# try again
		MDOLIST="$NOTLOADED"
	fi
	rm "${PNP_TMP}".?
#	cd /
}

run_shell(){
	[[ -z "$SHELL" ]] && for SHELL in /bin/ash /bin/bash /bin/sh; do
		[[ -e "$SHELL" ]] && break
	done
	export SHELL
	if [[ -n "$cmd_vkb_touchscreen" ]] || grep "^B: ABS=........" /proc/bus/input/devices ; then
		vkb
	else
		$SHELL
	fi
}

# minimalistic. debug
if [[ -z "$KV"  ]] && ! [[ -e /proc/version ]]; then
NEW_ROOT="/newroot"
NEW_ROOT_TYPE=auto
CDROOT=0
good_msg(){
echo "$*"
}
bad_msg(){
echo "! $*"
}
mount -t proc proc /proc
/bin/busybox --install -s
mount -t sysfs /sys /sys
echo /sbin/mdev >/proc/sys/kernel/hotplug
cd /sys
/sbin/mdev -s mem
/sbin/mdev -s &
#pids="$pids$! "
KV=`uname -r`
pnp_init
rm /sbin/modprobe
override_modprobe
syspnp
cd /
while true; do
	if [[ -n "$REAL_ROOT" ]] && mkdir "$NEW_ROOT" 2>/dev/null ; then
		if [[ -z "$NFSLIKE_FS" ]] || ! findnfsmount; then
			mount -t "$NEW_ROOT_TYPE" -o ro "$REAL_ROOT" "$NEW_ROOT" || rmdir "$NEW_ROOT"
		fi
		[[ "$NEW_ROOT" == /dev/nfs ]] && [[ -e /newroot ]] && NEW_ROOT="/newroot"
		if [[ -e "$NEW_ROOT" ]] && [[ -n "$LOOP" ]]; then
			LOOP_ROOT="$NEW_ROOT/mnt/livecd"
			if ! [[ -e "$LOOP_ROOT" ]]; then
				LOOP_ROOT="$NEW_ROOT.loop"
				mkdir "$LOOP_ROOT"
			fi
			if ! ( [[ -e "$LOOP_ROOT" ]] && mnt_loop /dev/loop0 "/newroot/$LOOP" "$LOOP_ROOT" && [[ -e "$LOOP_ROOT$cmd_real_init" ]] ) ; then
				umount "$LOOP_ROOT"
				losetup -d /dev/loop0
				rmdir "$LOOP_ROOT"
				umount "$NEW_ROOT"
				rmdir "$NEW_ROOT"
				LOOP_ROOT=""
			fi
		fi
	fi
	if [[ -n "$LOOP_ROOT" ]] && [[ -e "$LOOP_ROOT" ]]; then
		mod_unload
		umount /sys
		umount /proc
		mkdir /rd 2>/dev/null
		( mnt_loop /dev/loop1 /lib.loopfs /rd && link_dir /rd /lib ) ||
		( mnt_loop /dev/loop1 /rd.loopfs /rd && link_dir /rd )
		link_dir "$LOOP_ROOT"
		exec "$cmd_real_init" "$cmd_init_opts"
	elif [[ -e "$NEW_ROOT" ]]; then
		mod_unload
		umount /sys
		umount /proc
		exec /sbin/switch_root -c /dev/console "$NEW_ROOT" "$cmd_real_init" "$cmd_init_opts"
	else
		bad_msg "failed to mount root"
		echo -n "Enter root partition or 'shell':"
		REAL_ROOT=`SHELL="" vkb`
		set_root_loop "$REAL_ROOT"
		[[ "$REAL_ROOT" == shell ]] || continue
	fi
	bad_msg "failed to switch root"
	run_shell
done
fi
